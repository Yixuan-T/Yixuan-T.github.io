<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库_关系模型</title>
      <link href="/2020/03/07/%E6%95%B0%E6%8D%AE%E5%BA%93_%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/03/07/%E6%95%B0%E6%8D%AE%E5%BA%93_%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><hr><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="数据模型的三大基本要素"><a href="#数据模型的三大基本要素" class="headerlink" title="数据模型的三大基本要素"></a>数据模型的三大基本要素</h3><ul><li><strong>数据模型</strong>：</li></ul><p>是一个描述数据、数据联系、数据语义以及数据一致性约束的概念工具的集合</p><p>数据结构：<br>由一组创建数据库的规则（定义数据库的结构）组成</p><p>数据操作：<br>定义对数据进行的操作类型（包括更新和查找数据库中的数据以及修改数据库的结构）</p><p>约束条件：<br>一组数据完整性定义规则，确保数据的正确性</p><h3 id="层次数据模型"><a href="#层次数据模型" class="headerlink" title="层次数据模型"></a>层次数据模型</h3><p><strong>层次模型：</strong> 利用“记录”(包含多个“属性”)和“双亲子女关系(PCR)”来描述应用的数据结构</p><p><strong>层次模式(型)</strong>：利用层次模型描述一个应用的数据结构，称为一个层次模式（型：数据库的结构），为“树”结构。</p><p><img src="https://i.loli.net/2020/03/07/T326JLR4FDXqygx.png" alt=""></p><p><strong>非层次结构的描述：</strong>M：N联系，多双亲联系</p><p><img src="https://i.loli.net/2020/03/07/bhmaOnCrRUcoIux.png" alt=""></p><ul><li>解决方法1：采用副本<br>  缺点：数据冗余（增加空间，一致性维护难）</li></ul><p><img src="https://i.loli.net/2020/03/07/yFseCMDNwkglvA6.png" alt=""></p><ul><li>解决方法2：虚拟记录(优化方法)<br>  缺点：指针操作增加开销<br><img src="https://i.loli.net/2020/03/07/EU5vG2FC7PHxJLa.png" alt=""></li></ul><p><strong>定义物理存储结构：</strong></p><ul><li>邻接法：<br>按照层次树前序穿越的顺序，把所有记录值(子段定长，定长记录)依次邻接存放。</li></ul><p>即通过物理空间的位置相邻来实现层次顺序。</p><p><img src="https://i.loli.net/2020/03/07/X9xVhjUvcAZgNLd.png" alt=""></p><p><strong>定义基本数据操作</strong></p><ul><li>查找一个记录：从根记录开始，按给定条件沿层次路径进行搜索。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Get unique(GU)</span><br><span class="line">查找给定条件的记录</span><br><span class="line"></span><br><span class="line">Get next within parent(GNP)</span><br><span class="line">查找下一亲兄弟</span><br><span class="line"></span><br><span class="line">Get next(GN)</span><br><span class="line">找到当前记录的下一记录</span><br><span class="line"></span><br><span class="line">……</span><br></pre></td></tr></table></figure><p><strong>层次模型小结</strong>：</p><p>优点：</p><ol><li>数据模型比较简单，操作简单。    </li><li>对于实体间联系是固定的，且预先定义好的应用系统，性能较高。</li><li>提供良好的完整性支持。</li></ol><p>缺点：</p><ol start="2"><li>不适合于表示非层次性的联系。</li><li>插入和删除操作的限制比较多。</li><li>查询子女结点必须通过双亲结点</li></ol><h3 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h3><p><strong>基本概念：</strong></p><ul><li>记录的表示(内部结构)<br>  记录，数据项（允许为多值和复合数据）</li><li>联系的表示(外部结构)<br>  系（set）</li></ul><p>单属系：<br>    首记录&amp;属记录，<br>多属系：<br>    属记录值可以是不同不同记录类型</p><p><img src="https://i.loli.net/2020/03/07/BTDXqluKCJ13hp4.png" alt=""></p><p><strong>网状模型的不同特点</strong>：</p><ul><li>它去掉了层次模型的两个限制：<br>  允许多个结点没有双亲结点；<br>  允许结点有多个双亲结点。</li><li>它还允许两个结点之间有多种联系（复合联系）</li></ul><p><strong>网状模式（型）</strong></p><p>利用网状模型（记录&amp;系）来描述一个应用，可以得到一个网状模式（数据库的结构）</p><p>是一个“图”（而非一个“树”）</p><p><img src="https://i.loli.net/2020/03/07/QuFXqpAO6SY7jni.png" alt=""></p><p><strong>定义物理存储结构</strong><br>网状数据模型的存储结构,<br>依具体系统不同而不同，常用的方法是链接法，包括:</p><ul><li>单向链接</li><li>双向链接</li><li>环状链接</li><li>向首链拉等。</li></ul><p><img src="https://i.loli.net/2020/03/07/EqheWZ6SrkzyP5c.png" alt=""></p><p><strong>定义基本的数据操作</strong></p><ul><li>Find(查找)</li><li>Get(取数)</li><li>Store(存数)</li><li>Modify(修改)</li><li>Erase(删除)</li><li>Connect(加入)</li><li>Reconnect(转接)</li><li>Disconnect(撤离)</li></ul><p><strong>网状模型小结</strong></p><p>优点：</p><ol><li>能够更为直接地描述现实世界。</li><li>具有良好的性能，存取效率较高。</li></ol><p>缺点：</p><ol><li>其DDL语言极其复杂。</li><li>数据独立性较差。由于实体间的联系本质上通过存取路径指示的，因此1. 应用程序在访问数据时要指定存取路径。</li></ol><h2 id="关系模型的基本概念"><a href="#关系模型的基本概念" class="headerlink" title="关系模型的基本概念"></a>关系模型的基本概念</h2><h3 id="定义数据对象的结构"><a href="#定义数据对象的结构" class="headerlink" title="定义数据对象的结构"></a>定义数据对象的结构</h3><p>采用关系(table)描述：关系名加上一组属性！<br><img src="https://i.loli.net/2020/03/07/hrt9SVnYex7XQKM.png" alt=""></p><p>定义数据对象间的关联:仍采用关系(table)描述：关系名加上一组属性！<br><img src="https://i.loli.net/2020/03/07/rmV9h1tLNH3aRk8.png" alt=""></p><h3 id="第1范式-1NF"><a href="#第1范式-1NF" class="headerlink" title="第1范式(1NF)###"></a>第1范式(1NF)###</h3><p>要求关系的属性具有原子性！<br><img src="https://i.loli.net/2020/03/07/nP46KbDSsYedGQr.png" alt=""></p><h3 id="主码完整性约束"><a href="#主码完整性约束" class="headerlink" title="主码完整性约束"></a>主码完整性约束</h3><p>主码不能为空</p><h3 id="外码参照完整性约束"><a href="#外码参照完整性约束" class="headerlink" title="外码参照完整性约束"></a>外码参照完整性约束</h3><p><img src="https://i.loli.net/2020/03/07/8zKdlDIs3t4rZPS.png" alt=""></p><p>作用:<br>1)说明元组联联系<br>2)保证数据有效性</p><h3 id="模式图"><a href="#模式图" class="headerlink" title="模式图"></a>模式图</h3><ul><li><p>数据模型：<br>  描述数据对象的<br>  “内部结构”<br>  “相互关联”</p></li><li><p>线条：<br>  外键-参照关系，<br>  描述对象间的关联<br>  （“外部结构”）</p></li><li><p>矩形：<br>  关系模式，<br>  描述对象的特征<br>   （内部结构）<br>  上方-关系名称<br>  下划线(组合)-主键</p></li></ul><p><img src="https://i.loli.net/2020/03/07/Cf43aw1e5OVBAD8.png" alt=""></p><h3 id="关系模型的完整性约束"><a href="#关系模型的完整性约束" class="headerlink" title="关系模型的完整性约束"></a>关系模型的完整性约束</h3><ul><li>定义:<br>  是对关系的某种约束条件。</li><li>目的:<br>  用于保证关系数据库中数据的正确性和可靠性。</li><li>类型:<br>  实体完整性规则<br>  参照完整性规则（引用完整性规则 ）<br>  域完整性规则（用户自定义完整性规则）</li></ul><p><strong>实体完整性规则</strong></p><p>规则要求：<br>在任何关系的任何一个元组中，主键的值不能为空值、也不能取重复的值。</p><ul><li>目的：用于保证数据库表中的每一个元组都是惟一的。</li></ul><p><strong>域完整性规则(用户定义完整性规则)</strong></p><p>规则要求:<br>由用户根据实际情况，定义表中属性的取值范围<br>例如：性别只能是男和女、年龄不能为负值、成绩在0—100之间等。</p><ul><li>目的<br>用于保证给定字段中数据的有效性,即保证数据的取值在有效的范围内。</li></ul><p><strong>参照完整性规则（引用完整性规则）</strong></p><p>规则要求：<br>“不引用不存在的实体”。即：不允许在一个关系中引用另一个关系中不存在的元组。</p><ul><li>目的<br>用于确保相关联的表间的数据保持一致。</li></ul><h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><p><img src="https://i.loli.net/2020/03/07/6fQuN7dtExkqeWj.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程第五章</title>
      <link href="/2020/03/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
      <url>/2020/03/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h1><hr><h2 id="5-1-什么是敏捷"><a href="#5-1-什么是敏捷" class="headerlink" title="5.1 什么是敏捷"></a>5.1 什么是敏捷</h2><p>敏捷团队是能够<strong>适当响应变更</strong>的灵活团队。</p><p>敏捷团队意识到<strong>软件是团队中所有人共同开发完成</strong>的，这些人的个人技能和合作能力是项目成功的关键所在。</p><p>敏捷鼓励能够使<strong>沟通</strong>更便利的团队结构和协作态度。</p><p>敏捷强调<strong>可运行软件的快速交付</strong>而不那么看重中间产品；它将<strong>客户</strong>作为开发团队的一部分开展工作，以消除持续，普遍存在于多数软件项目中的“区分我们和他们”的态度；它意识到在不确定的世界里计划是有局限性的，项目<strong>计划必须是可以灵活调整</strong>的。</p><h2 id="5-2-敏捷及变更成本"><a href="#5-2-敏捷及变更成本" class="headerlink" title="5.2 敏捷及变更成本"></a>5.2 敏捷及变更成本</h2><p><img src="https://i.loli.net/2020/03/05/flv5wxWkgAbz1OI.png" alt=""></p><p>敏捷的拥护者认为，一个设计良好的敏捷过程拉平了变更曲线，使软件开发团队在没有超常规的时间和费用影响的情况下，在软件项目后期能够适应各种变更。</p><h2 id="5-3-什么是敏捷过程"><a href="#5-3-什么是敏捷过程" class="headerlink" title="5.3 什么是敏捷过程"></a>5.3 什么是敏捷过程</h2><h3 id="5-3-1-敏捷原则"><a href="#5-3-1-敏捷原则" class="headerlink" title="5.3.1 敏捷原则"></a>5.3.1 敏捷原则</h3><ol><li>我们的最高目标是，通过尽早和持续地交付有价值的软件来满足客户。</li><li>欢迎对需求提出变更——即使是在项目开发后期。要善于利用需求变更，帮助客户获得竞争优势。</li><li>要不断交付可用的软件，周期从几周到几个月不等，且越短越好</li><li>项目过程中，业务人员与开发人员必须在一起工作。</li><li>要善于激励项目人员，给他们以所需要的环境和支持，并相信他们能够完成任务。</li><li>无论是团队内还是团队间，最有效的沟通方法是面对面的交谈。</li><li>可用的软件是衡量进度的主要指标。</li><li>敏捷过程提倡可持续的开发。项目方、开发人员和用户应该能够保持恒久稳定的进展速度。</li><li>对技术的精益求精以及对设计的不断完善将提升敏捷性。</li><li>要做到简洁，即尽最大可能减少不必要的工作。这是一门艺术。</li><li>最佳的架构、需求和设计出自于自组织的团队。</li><li>团队要定期反省如何能够做到更有效，并相应地调整团队的行为。</li></ol><p><strong>关键点：尽管敏捷过程支持变更，但检查变更的原因仍然是重要的。</strong></p><h2 id="5-4-极限编程-XP"><a href="#5-4-极限编程-XP" class="headerlink" title="5.4 极限编程 XP"></a>5.4 极限编程 XP</h2><h3 id="5-4-1-极限编程过程"><a href="#5-4-1-极限编程过程" class="headerlink" title="5.4.1 极限编程过程"></a>5.4.1 极限编程过程</h3><p>XP使用面向对象方法作为推荐的开发范式，它包含了<strong>策划、设计、编码和测试</strong>4个框架活动的规则和实践。</p><p><img src="https://i.loli.net/2020/03/05/rQghw3iEV8IaDNz.png" alt=""></p><ul><li><strong>策划</strong></li></ul><p>策划活动开始于倾听，这是一个需求收集活动，该活动要使XP团队技术成员理解软件的商业背景，充分感受要求的输出和主要特性及主要功能。产生用户<strong>故事</strong>。</p><p>客户和XP团队将故事分组，并置于XP团队将要开发的下一个发行版本中。</p><p>项目的第一个发行版本交付之后，XP团队计算项目速度，项目速度是第一个发行版本中实现的客户故事个数。</p><p>开发过程中，客户可以增加故事、改变故事的权值、分解或者去掉故事。接下来由XP团队重新考虑所有剩余的发行版本并相应修改计划。</p><p>－**　设计**</p><p>XP设计严格遵顼<strong>KIS</strong>（保持简洁）原则，即使用简单的设计，而不是复杂的表述。设计为故事提供恰好可实现的指导，而不鼓励额外功能性设计。</p><p>XP鼓励的重构：以不改变其外部功能或行为而改进设计的内部结构。</p><p>重构的目的是控制那些“可以根本改进设计”的小的设计变更所要进行的修改。</p><p>－　<strong>编码</strong></p><p>XP推荐在故事开发和初步设计完成之后，团队不是直接开始编码，而是开发一系列用于检测本次（软件增量）发布的包括所有故事的<strong>单元测试</strong>，从而向开发者提供及时反馈。</p><p><strong>结对编程</strong>：XP建议两个人面对同一台计算机共同为一个故事开发代码。实施过程中，不同成员担任的角色略有不同。</p><p>－　<strong>测试</strong></p><p>所建立的单元测试应当使用一个可以自动实施的框架，这种方式支持每当代码修改之后即时的回归测试策略。</p><p>XP验收测试也成为客户测试，由客户规定技术条件，并且着眼于客户可见的、可评审的系统级的特性和功能、验收测试根据本次软件发布中所实现的用户故事而确定。</p><h3 id="5-4-2-工业极限编程-IXP"><a href="#5-4-2-工业极限编程-IXP" class="headerlink" title="5.4.2 工业极限编程 IXP###"></a>5.4.2 工业极限编程 IXP###</h3><p>IXP合并了六个新实践：</p><ul><li>准备评估</li><li>项目社区</li><li>项目特许</li><li>测试驱动管理</li><li>回顾</li><li>持续学习</li></ul><h2 id="5-5-其他敏捷过程模型"><a href="#5-5-其他敏捷过程模型" class="headerlink" title="5.5 其他敏捷过程模型"></a>5.5 其他敏捷过程模型</h2><h3 id="5-5-1-Scrum"><a href="#5-5-1-Scrum" class="headerlink" title="5.5.1 Scrum"></a>5.5.1 Scrum</h3><p>过程由“需求、分析、设计、演化和交付”等框架性活动组成。<br>每一个框架活动中，发生于一个过程模式中的工作任务成为一个冲刺（sprint）<br><img src="https://i.loli.net/2020/03/05/pKhvjeROw6T9l1P.png" alt=""></p><h3 id="5-5-2-动态系统开发方法"><a href="#5-5-2-动态系统开发方法" class="headerlink" title="5.5.2 动态系统开发方法"></a>5.5.2 动态系统开发方法</h3><p>该方法提供一种框架，使其“通过在可控项目环境中使用增量原型开发模式以完全满足对时间有约束的系统的构建和维护”</p><p>DSDM使迭代软件过程，每一个迭代都遵循80%原则，即每个增量只完成能够保证顺利进入下一增量的工作，剩余的细节则可以在知道更多业务需求或者提出并同意变更之后完成。</p><p>以下是三个不同的迭代周期：</p><p>功能模型迭代，设计和构建迭代，实现。</p><h3 id="5-5-3-敏捷建模-AM"><a href="#5-5-3-敏捷建模-AM" class="headerlink" title="5.5.3 敏捷建模 AM"></a>5.5.3 敏捷建模 AM</h3><p>AM是一种集于实践的方法学，用于对基于软件的系统实施有效建模和文档编制。在软件开发项目中，AM是可以有效并以轻量级方式用于软件建模的标准、原则和实践。由于敏捷模型只是大致完善，并不要求完美，因此敏捷模型比传统的模型更有效。</p><p>原则：</p><ul><li>有目的的模型。</li><li>使用多个模型。</li><li>轻装上阵。</li><li>内容重于表示形式。</li><li>理解模型及工具。</li><li>适应本地需要。</li></ul><h3 id="5-5-4-敏捷统一过程"><a href="#5-5-4-敏捷统一过程" class="headerlink" title="5.5.4 敏捷统一过程"></a>5.5.4 敏捷统一过程</h3><p><strong>“在大型上连续” “在小型上迭代”</strong></p><p>每个AUP迭代执行以下活动：</p><ul><li>建模</li><li>实现</li><li>测试</li><li>部署</li><li>配置及项目管理</li><li>环境管理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_数组</title>
      <link href="/2020/03/05/java-%E6%95%B0%E7%BB%84/"/>
      <url>/2020/03/05/java-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><hr><h2 id="java内存空间分配"><a href="#java内存空间分配" class="headerlink" title="java内存空间分配"></a>java内存空间分配</h2><p><img src="https://i.loli.net/2020/03/05/xu8I9JXZM3ygiwC.png" alt=""></p><p><strong>共享区域：所有线程共享</strong></p><ul><li>堆：存放对象实例和数组， JVM 所管理的内存中最大的一块</li><li>方法区：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li></ul><p><strong>私有区域：每个线程私有</strong></p><ul><li>栈：线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型。由栈帧组成，栈帧包含一Java方法调用的状态。</li><li>程序计数器：选取下一条需要执行字节码指令。</li><li>本地方法栈：Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</li></ul><h2 id="栈内存和堆内存"><a href="#栈内存和堆内存" class="headerlink" title="栈内存和堆内存"></a>栈内存和堆内存</h2><p><strong>基本数据类型和引用的变量存放于栈内存。</strong></p><ul><li><p>声明时即会分配存储空间，有默认值： int i;</p></li><li><p>当超过变量的作用域后，存储空间会自动释放</p><p><strong>数组和对象存放于堆内存。</strong></p></li><li><p>由new命令创建</p></li><li><p>堆内存中的对象和数组只能由栈内存中的引用(reference)变量来访问，引用相当于是指针</p></li><li><p>数组和对象在没有引用变量指向它的时候，变成垃圾；由java虚拟机垃圾回收器来自动回收</p></li></ul><h2 id="基本数据类型的默认初始值"><a href="#基本数据类型的默认初始值" class="headerlink" title="基本数据类型的默认初始值"></a>基本数据类型的默认初始值</h2><p><img src="https://i.loli.net/2020/03/05/uCfimq3F7PWOhsa.png" alt=""></p><h2 id="一维数组定义"><a href="#一维数组定义" class="headerlink" title="一维数组定义"></a>一维数组定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">声明：int  a[ ]；   或者   int[ ]  a；</span><br></pre></td></tr></table></figure><p>这里<strong>只有数组的引用的定义</strong>，没有为数组元素分配空间，只为数组的引用分配了空间，a的值为null。</p><p>分配内存： &lt;数组名&gt;= new  &lt;类型&gt;[ &lt;长度&gt; ]；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例子：a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];     </span><br><span class="line"><span class="comment">//创建了一个包含５个元素的数组ａ，每个元素被自动初始化为０</span></span><br></pre></td></tr></table></figure><p>访问数组中的元素：a[0], a[1], ….</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">声明并分配空间：int a[ ] &#x3D;new int[5];</span><br></pre></td></tr></table></figure><p>在声明数组时，可以为数组分配内存并赋初值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[ ]&#x3D;&#123;0，1，2，3，4&#125;；</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/05/938zWI5wgDU2ihR.png" alt=""></p><p>Java中使用数组引用.length表示数组的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println( a.length );</span><br></pre></td></tr></table></figure><p><strong>越界保护</strong>：若访问数组时下标越界，则扔出异常</p><h2 id="for-each-语句"><a href="#for-each-语句" class="headerlink" title="for-each 语句"></a>for-each 语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> e = a[i];           sum = sum + e;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : a)</span><br><span class="line">sum = sum + e;</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure><p>用for-each语句遍历一个数组或集合中的所有元素，代码更简洁。语法：for ( type e : a ){…} </p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>二维数组是一个特殊的一维数组，它的每个元素都是一个一维数组（多维数组也是同理）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  two[][]  ； <span class="comment">//声明,或者int[][]two</span></span><br><span class="line">two=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];  <span class="comment">//分配内存</span></span><br></pre></td></tr></table></figure><p>在定义二维数组时也可以赋初值，将数组元素的值用多层括号括起来，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> two[][]=&#123;&#123;<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>&#125;，&#123;<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>&#125;&#125;；</span><br></pre></td></tr></table></figure><p>二维数组还有另外一种初始化方式，就是从最高维开始，分别为每一维分配空间。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] two =<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][ ];</span><br><span class="line">two[<span class="number">0</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">two[<span class="number">1</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];<span class="comment">//two[0]、two[1]两数组长度不一样</span></span><br></pre></td></tr></table></figure><h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><p>为方便数组的使用，Java在包java.util定义了一个叫Arrays的类。Arrays类提供了多个操作数组的静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> type[] copyOf (type[] original,<span class="keyword">int</span> length)</span><br><span class="line"><span class="comment">//将original数组复制为一个新数组，其中length为新数组的长度。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> binarySearch（type[] a,type key）</span><br><span class="line"><span class="comment">//使用二分搜索法在数组a中搜索指定值key；</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> equals（type[] a,type[] b）</span><br><span class="line"><span class="comment">//比较两个数组是否相等；</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span> <span class="params">(type[] a, type val)</span></span></span><br><span class="line"><span class="function"><span class="comment">//用一个指定的值val填充数组a；</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span> <span class="params">(type[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, type val)</span></span></span><br><span class="line"><span class="function"><span class="comment">//与前一个方法类似，但填充时仅仅针对下标为fromIndex到toIndex-1的数组元素赋值为val；</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> sort（type[] a）</span></span><br><span class="line"><span class="function"><span class="comment">//对数组a排序；</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java程序设计基础</title>
      <link href="/2020/03/02/java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/03/02/java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA-程序设计基础"><a href="#JAVA-程序设计基础" class="headerlink" title="JAVA_程序设计基础"></a>JAVA_程序设计基础</h1><hr><h2 id="标识符、关键字、注释、常量变量"><a href="#标识符、关键字、注释、常量变量" class="headerlink" title="标识符、关键字、注释、常量变量##"></a>标识符、关键字、注释、常量变量##</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p><strong>标识符</strong>：为程序中的各个元素（如变量、类名、对象名）进行命名。</p><p>一般地，在Java 中标识符是以<strong>字母、下划线（_）、美元符号（$）</strong>等开始的一个字符序列，后面可以跟字母、下划线、美元符号、数字等字符。所以，<strong>不能以数字开始</strong>，但其他位置可以使用 </p><p><em>标识符是大小写敏感的，不能和关键字相同</em> </p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>所有的关键字都是<strong>小写</strong>的。</p><ul><li>包相关关键字：package   import</li><li>用于数据类型的关键字：byte   short  int   long  float double  char   boolean</li><li>用于流程控制语句的关键字：if  else  switch  case  default  do  while  for  break  continue</li><li>方法、类型、变量的修饰关键字：private   public  protected   final  static   abstract   synchronized   volatile</li><li>异常处理关键字：try  catch  finally  throw  throws</li><li>对象相关关键字：new  extends  implements  class  instanceof  this  super</li><li>字面值常量关键字：false   true    null</li><li>方法相关关键字：return   void</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行注释：单行注释以“//”开头，至该行结尾<br>多行注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  注释文本</span></span><br><span class="line"><span class="comment">   ……</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>文档注释:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**注释文本</span></span><br><span class="line"><span class="comment">*注释文本</span></span><br><span class="line"><span class="comment">*……</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>该类注释可通过jdk下的javadoc.exe程序提取并自动为代码生成文档，Java API文档也是通过这种方式生成。</p><h3 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h3><p>变量<strong>定义</strong>：[修饰符] &lt;类型名&gt;  &lt;变量名&gt; [=&lt;初值&gt;][,&lt;变量名&gt;[=&lt;初值&gt;]…]； </p><ul><li>例如：int i；int j=5，k=4;</li></ul><p>按作用域可以将变量大致分为： </p><ul><li><strong>局部变量</strong>是在方法内部或代码块中声明的变量，它的作用域为所在的代码块，在程序中，以“{ …… }”为界。 </li><li><strong>类成员变量</strong>，它的作用域是整个类。</li><li><strong>方法参数</strong>的作用域，是所在的方法 </li></ul><p><strong>常量定义</strong>：变量定义前加<strong>final关键字</strong>即可。<br>final int NUMBER=100;<br>final int MAX_LOOP=5;<br>常量命名规范：<strong>常量名全部大写</strong></p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><img src="https://i.loli.net/2020/03/02/Vd4N8lseWBj21LM.png" alt=""></p><p>###整数类型 ###</p><table><thead><tr><th>数据类型</th><th>所占位数</th><th>数的范围</th></tr></thead><tbody><tr><td>byte</td><td>8</td><td>-2^7 ～(2^7 -1)</td></tr><tr><td>short</td><td>16</td><td>-2^15 ～(2^15 -1)</td></tr><tr><td>int</td><td>32</td><td>-2^31 ～(2^31 -1)</td></tr><tr><td>long</td><td>64</td><td>-2^63 ～(2^63-1)</td></tr></tbody></table><p><strong>Java中的整数都用二进制的补码表示</strong>。<br>原码：最高位为符号位，正数时为0，负数时为1。<br>补码: 非负数的补码就是原码；负数的补码是将其对应正数的原码按位取反再加1。</p><p>表示<strong>long</strong>型常量时，需在数字后面<strong>加上后缀L或l</strong>。例如3L表示一个long型的常量，而不是int型。</p><p>Java的基本数据类型都有固定的数据位，不随运行平台的变化而变化。计算时注意可能产生的溢出。</p><p>Java中的整数有三种进制表示：</p><p>十进制：用0~9的数值表示，<strong>首位不能为0</strong>，例如：124，-100；</p><p>八进制：<strong>以0开头</strong>，后跟多个0~7之间的数字，如0134；</p><p>十六进制：<strong>以0x或者0X开头</strong>，后跟多个0<del>9之间的数字、或A</del>F之间的的大写字、或者a<del>f之间的小写字母。a</del>f或者A-F分别表示10~15，例如，0x10，等于十进制数16。</p><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>Java中，字符类型char用16位的<strong>Unicode</strong>码表示。<br>同c语言，<strong>字符常量用单引号包围表示</strong>，如 ’a’；<br>Unicode是一个编码方案，表示了0到65535的整数与65536个字符间的匹配关系，比如49为字符’1’ ，65为字符’A’ ， 19968为汉字字符’一’。 ASCII码基于拉丁字母只定义了128个字符。</p><table><thead><tr><th>转义字符</th><th>描述</th></tr></thead><tbody><tr><td>\uxxxx</td><td>1到4位16进制数所表示的字符(xxxx)</td></tr><tr><td>\</td><td>反斜杠</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\t</td><td>横向跳格</td></tr></tbody></table><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><table><thead><tr><th>数据类型</th><th>所占位数</th><th>数的范围</th></tr></thead><tbody><tr><td>float（单精度浮点数）</td><td>32</td><td>3.4e-038 ～3.4e+038</td></tr><tr><td>double（双精度浮点数）</td><td>64</td><td>1.7e-308 ～ 1.7e+308</td></tr></tbody></table><p>用IEEE 754 标准将二进制表示成浮点数<br>比如32位的float分成三个区域：1位的符号位s、8位的指数位e、23位的有效数位f。<br>一个浮点数默认为double型。<strong>在一个浮点数后加字母F或f</strong>，表示float型。</p><ul><li>常数3.45的类型是double；3.45F的类型是float。</li></ul><h3 id="各类型数据间的相互转换"><a href="#各类型数据间的相互转换" class="headerlink" title="各类型数据间的相互转换"></a>各类型数据间的相互转换</h3><ul><li><p><strong>自动类型转换</strong> ：从表达范围小的类型向表达范围大的类型发生自动类型转换<br>  范围由小到大：byte，short/char, int, long, float, double<br>  byte, short, char类型进行运算时会自动转换为int类型</p></li><li><p><strong>强制类型转换</strong> ：由表达范围大的向小的类型转换时，需要强制类型转换；因为此时可能会发生数据截断。</p></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table><thead><tr><th>运算符</th><th>用法</th><th>含义</th><th>结合性</th></tr></thead><tbody><tr><td>+</td><td>op1+op2</td><td>加法</td><td>左</td></tr><tr><td>-</td><td>op1-op2</td><td>减法</td><td>左</td></tr><tr><td>*</td><td>op1*op2</td><td>乘法</td><td>左</td></tr><tr><td>/</td><td>op1/op2</td><td>除法</td><td>左</td></tr><tr><td>%</td><td>op1%op2</td><td>模运算(求余)</td><td>左</td></tr><tr><td>+</td><td>+op1</td><td>正数</td><td>右</td></tr><tr><td>-</td><td>-op1</td><td>负数</td><td>右</td></tr><tr><td>++</td><td>++op1,op1++</td><td>自增</td><td>右，左</td></tr><tr><td>–</td><td>–op1, op1–</td><td>自减</td><td>右，左</td></tr></tbody></table><ul><li>对于二元运算符，运算结果的数据类型为两个操作数中表达范围较大的类型。例如，<br>一个int和double运算的结果为double。对于一元运算符，运算结果的类型与操作数的类型相同</li></ul><p>自增、自减运算符有前缀和后缀两种形式，</p><ul><li>当是前缀形式（即++、–符号出现在变量的左侧）时，对变量实施的运算是“<strong>先运算后使用</strong>”； </li><li>当是后缀形式时，对变量实施的运算是“<strong>先使用后运算</strong></li></ul><p>再次强调：byte，short，char等类型进行算数运算时，会先自动转换为int类型再运算。</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table><thead><tr><th>运算符</th><th>示例</th><th>含义</th></tr></thead><tbody><tr><td>=</td><td>count = 2</td><td>count变量赋值为2</td></tr><tr><td>+=</td><td>count += 2</td><td>count = count + 2</td></tr><tr><td>-=</td><td>count -= 2</td><td>count = count - 2</td></tr><tr><td>*=</td><td>count *= 2</td><td>count = count * 2</td></tr><tr><td>/=</td><td>count /= 2</td><td>count = count / 2</td></tr><tr><td>%=</td><td>count %= 2</td><td>count = count % 2</td></tr></tbody></table><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(boolean_expr) ?  </span><br><span class="line">true_statement : false_statement；</span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>Java中，boolean（布尔）类型的数据只有两种取值：true、false</p><p>逻辑运算只能处理布尔类型的数据，所得结果也是布尔值 </p><p>运算优先级：非&gt;与&gt;或 </p><table><thead><tr><th>运算符</th><th>示例</th><th>含义</th><th>结合性</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>Op1 &amp;&amp; Op2</td><td>逻辑与运算：仅当两个运算符的值都为true时结果为true</td><td>左</td></tr><tr><td>&#124; &#124;</td><td>Op1 &#124;&#124; Op2</td><td>逻辑或运算：两个运算符中若有其一值为true则结果为true</td><td>左</td></tr><tr><td>!</td><td>! Op</td><td>逻辑非运算：!true=false, !flase=true</td><td>右</td></tr></tbody></table><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ul><li>&amp;，示例“Op1  &amp;  Op2”，表示使Op1和Op2按位相与</li><li>|，示例“Op1  |  Op2”，表示使Op1和Op2按位相或</li><li>~ ，示例“~Op1”，表示对Op按位取反</li><li>^，示例“Op1 ^ Op2”，表示使Op1和Op2按位异或</li><li>‘&lt;&lt;’，示例“Op1 &lt;&lt;  Op2”，使Op1左移Op2位，右补0</li><li>‘&gt;&gt;’，示例“Op1 &gt;&gt;  Op2”，使Op1右移Op2位(带符号，左边补充符号位)</li><li>‘&gt;&gt;&gt;’，示例“Op1 &gt;&gt;&gt;  Op2”,使Op1无符号右移Op2位(左边始终补添0)</li></ul><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p><strong>表达式</strong>是程序设计语言的基本组成部分，表示一种求值的规则，是由运算符和操作数组成的符号序列。</p><p>在对表达式进行运算时，遵循一定的规则，要按<strong>运算符的优先级</strong>从高到低进行，同级的运算符则按从左到右的方向进行。</p><p>以下符号优先级从高到低排列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.. [] () ++ -- ! ~ </span><br><span class="line">2.new (type) </span><br><span class="line">3.* &#x2F; %     </span><br><span class="line">4.+ -   </span><br><span class="line">5.&gt;&gt;  &gt;&gt;&gt;  &lt;&lt;       </span><br><span class="line">6.&lt; &gt; &lt;&#x3D; &gt;&#x3D;   </span><br><span class="line">7.&#x3D;&#x3D; !&#x3D;     </span><br><span class="line">8.&amp;  </span><br><span class="line">9.^ </span><br><span class="line">10.|    </span><br><span class="line">11.&amp;&amp; </span><br><span class="line">12.|| </span><br><span class="line">13.? :</span><br><span class="line">14.&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; ^&#x3D;</span><br><span class="line">15.&amp;&#x3D;  &lt;&lt;&#x3D; &gt;&gt;&#x3D; &gt;&gt;&gt;&#x3D;</span><br></pre></td></tr></table></figure><h2 id="程序控制语句"><a href="#程序控制语句" class="headerlink" title="程序控制语句"></a>程序控制语句</h2><h3 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h3><p>Java中的选择语句包括：if语句和switch语句。</p><p><strong>if语句</strong>:</p><p>条件condition可以是任何返回布尔值的表达式。条件为真时执行语句statement1，假时执行statement2。else子句是可选的。</p><p>statement1和2可以是单个语句，也可以是程序块。后者必须加大括号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition) </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(condition)        </span><br><span class="line">statement;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      statement; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">      statement</span><br></pre></td></tr></table></figure><p><strong>switch语句</strong>:</p><p>表达式expression返回的类型必须为<strong>byte，short，int，char</strong>，或者<strong>字符串</strong>。</p><p>每个case语句后的值必须是与表达式类型兼容的特定的一个常量</p><p>一旦case匹配，就会顺序执行后面的程序代码，直到遇见break。<br>如果没有一个case常量与表达式的值匹配，则执行default语句(可选)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line"><span class="keyword">case</span> value1:</span><br><span class="line">      ... <span class="comment">// 语句序列</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> value2:</span><br><span class="line">      ... <span class="comment">//语句序列</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> valueN:</span><br><span class="line">      ... <span class="comment">//语句序列</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">      ... <span class="comment">//语句序列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p><strong>while语句</strong><br>循环语句，当它的条件表达式是true时，while语句重复执行循环体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>do-while语句</strong><br>do-while循环总是先执行循环体，然后再计算条件表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">  &#x2F;&#x2F; 循环体</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">while(condition);</span><br></pre></td></tr></table></figure><p><strong>for语句</strong></p><ol><li>执行初始化部分；</li><li>计算条件condition的值；</li><li>若为true，则执行循环体，之后执行迭代iteration部分，然后跳转到第二步；</li><li>若为false，则循环终止</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(initialization; condition; iteration) &#123;</span><br><span class="line">      ... &#x2F;&#x2F; 循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3><p>跳转语句包括：</p><ul><li>return语句</li><li>break语句</li><li>continue语句</li></ul><p><strong>return语句</strong>用来明确地从一个方法返回：<br>若返回一个值，其格式如下： return 返回值;<br>若无返回值，则直接： return ; </p><p><strong>使用break</strong> 退出循环语句或switch语句</p><p><strong>使用continue</strong>终止循环的本次迭代继续进入下一次迭代</p><p><strong>带标记的break &amp; continue</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">outer: <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (j &gt; i) &#123;</span><br><span class="line">                   System.out.println();</span><br><span class="line">                   <span class="keyword">continue</span> outer;</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.print(<span class="string">" "</span> + (i * j));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br></pre></td></tr></table></figure><ul><li>针对标记处的程序行break或continue，该语法类似goto 的功能</li><li>仅建议在继续或退出双重以上循环时使用</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程第四章</title>
      <link href="/2020/03/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
      <url>/2020/03/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程第四章"><a href="#软件工程第四章" class="headerlink" title="软件工程第四章"></a>软件工程第四章</h1><hr><h2 id="4-1-惯用过程模型"><a href="#4-1-惯用过程模型" class="headerlink" title="4.1 惯用过程模型"></a>4.1 惯用过程模型</h2><h3 id="4-1-1-瀑布模型"><a href="#4-1-1-瀑布模型" class="headerlink" title="4.1.1 瀑布模型"></a>4.1.1 瀑布模型</h3><p><strong>瀑布模型</strong>又称为经典生命周期，它提出了一个系统的、顺序的软件开发方法，从用户需求规格说明开始，通过策划、建模、构建和部署的过程，最终提供完整的软件支持。(可能会导致任务阻塞)<br><img src="https://i.loli.net/2020/03/01/DvhEQI4aSY2JBwU.png" alt=""></p><p><strong>V模型</strong>（瀑布模型的变体），随着软件团队工作沿着V模型左侧步骤向下推进，基本问题需求逐步细化，形成了对问题及解决方案详尽且技术性的描述。一旦编码结束，团队沿着V模型右侧的步骤向上推进工作，其本质上是执行了一系列测试。<br><img src="https://i.loli.net/2020/03/01/Hrf7lOutVsJjiBU.png" alt=""></p><p><strong>优点</strong>：</p><ol><li>强调开发的阶段性，各阶段具有顺序性和依赖性</li><li>强调早期调研和需求分析，推迟编码实现的观点</li><li>提供了一个摸板，这个摸板使得分析、设计、编码、测试和支持的方法可以 在该摸板下有一个共同的指导</li></ol><p><strong>缺点</strong>：<br>2. 文档驱动，用户无法及时了解产品的情况<br>2. 依赖早期调研和需求分析，很难适应在许多项目开始阶段必然存在的不确定性。<br>2.  流程单一，必须要完成前一阶段的任务，才能进行下一阶段，开发过程中的 成功经验无法用于本产品。<br>2.  测试在后期引入，对于系统存在的重大缺陷，如果在可执行程序评审之前没有被发现，将可能造成重大损失。<br>2. 组织庞大，人员闲置。<br>3. </p><h3 id="4-1-2-增量过程模型"><a href="#4-1-2-增量过程模型" class="headerlink" title="4.1.2 增量过程模型"></a>4.1.2 增量过程模型</h3><p><img src="https://i.loli.net/2020/03/01/YazXpleMQNf42F8.png" alt=""><br>该模型综合了线性过程流和并行过程流的特征。增量过程模型<strong>以迭代的方式运用瀑布模型</strong>，把软件产品作为一系列的增量构件来设计、编码、集成和测试。</p><p>每个构件由多个相互作用的模块构成，并且能够完成特定的功能。使用增量模型时，<em>第一个增量往往是核心功能</em>。</p><p>我感觉类似于计算机组成原理中的流水线，随着时间的推移，增量模型在每个阶段都运用线性序列。每个线性序列生产出软件的可交付增量。</p><p><strong>优点</strong>：<br>3. 能在较短的时间内向用户提交可完成部分工作的产品。<br>3. 逐步增加产品功能可以使用户有充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。<br>3. 规避技术风险<br>3. 可并行开发构件，加快开发的进度</p><p><strong>缺点</strong>：<br>4.  没有考虑软件的整体质量和长期的可维护性。<br>4.  大部分情况是不合适的操作算法被采用目的为了演示功能，不合适的开发工具被采用仅仅为了它的方便，还有不合适的操作系统被选择等等。<br>4.  由于达不到质量要求产品可能被抛弃，而采用新的模型重新设计</p><h3 id="4-1-3-演化过程模型"><a href="#4-1-3-演化过程模型" class="headerlink" title="4.1.3 演化过程模型"></a>4.1.3 演化过程模型</h3><p>演化模型是迭代的过程模型，以下是两种常用的演化过程模型：</p><p><strong>原型开发</strong>：</p><ul><li>从需求收集开始，开发者和客户在一起定义软件的总体目标，标识已知的需求并且规划出需要进一步定义的区域。</li><li>然后是“快速设计”，它集中于软件中那些对客户可见的部分的表示，这将导致原型的创建，并由客户评估并进一步精化待开发软件的需求。</li><li>逐步调整原型使其满足客户的需求，这个过程是迭代的。其流程从听取客户意见开始、随后是建造/修改原型、客户测试运行原型、然后回头往复循环直到客户对原型满意为止。</li></ul><p><img src="https://i.loli.net/2020/03/01/ntUPMFxRNfvHuj3.png" alt=""></p><p><strong>优点</strong>：<br>5. 能让人（开发者或客户很快见到产品，有成就感。<br>5. 能渐进地启发客户提出新的要求或任务。</p><p><strong>缺点</strong>：<br>6. 没有考虑软件的整体质量和长期的可维护性。<br>6. 大部分情况是不合适的操作算法被采用目的为了演示功能，不合适的开发工具被采用仅仅为了它的方便，还有不合适的操作系统被选择等等。<br>6. 由于达不到质量要求产品可能被抛弃，而采用新的模型重新设计。</p><hr><p><strong>螺旋模型</strong>：</p><p>螺旋模型是一种<strong>演进式软件过程模型</strong>，结合了原型的迭代性质和瀑布模型的系统性和可控性的特点，具有快速开发越来越完善软件版本的潜力。</p><p>螺旋模型是一种<strong>风险驱动型</strong>的过程模型生成器，对于软件集中的系统，它可以指导多个利益相关者的协同工作。它有两个显著特点：</p><ol><li>采用<strong>循环的方式</strong>逐步加深系统定义和实现的深度，同时降低风险。</li><li>二是确定一系列<strong>里程碑</strong>作为支撑点，确保利益相关者认可是可行的且可令各方满意的系统解决方案。</li></ol><p>开发步骤：沿螺线自内向外，每旋转一圈便开发出更为完善的一个新的软件版本。</p><p>例如，在第一圈，确定了初步的目标、方案和限制条件以后，转入右上象限，对风险进行识别和分析。如果风险分析表明，需求有不确定性，那么在右下的工程象限内，所建的原型会帮助开发人员和客户，考虑其它开发模型，并对需求做进一步修正。客户对工程成果做出评价之后，给出修正建议。在此基础上需再次计划，并进行风险分析。在每一圈螺线上，风险分析的终点做出是否继续下去的判断。假如风险过大，开发者和用户无法承受，项目有可能终止。多数情况下沿螺线的活动会继续下去，自内向外，逐步延伸，最终得到所期望的系统。</p><p><img src="https://i.loli.net/2020/03/01/Moms8wUy6ktR4ax.png" alt=""></p><p><strong>优点</strong>：</p><ol><li>强调风险</li><li>强调阶段质量</li><li>提供纠错的机会</li></ol><p><strong>缺点</strong>：</p><ol><li>每个阶段都要提出被选方案，进行风险分析，研发周期长，效率低</li><li>必须要转业的风险分析人员的参与</li></ol><h3 id="4-1-4-并发模型"><a href="#4-1-4-并发模型" class="headerlink" title="4.1.4 并发模型"></a>4.1.4 并发模型</h3><p>也叫做<strong>并发工程</strong>，它允许软件团队表述本章所描述的任何过程模型中的迭代元素和并发元素。<br><img src="https://i.loli.net/2020/03/01/h4wPs16loG3eV8y.png" alt=""></p><p>(很像操作系统对进程管理的感觉)</p><p>它不是把软件工程活动、动作和任务局限在一个事件的序列，而是定义了一个<strong>过程网络</strong>，网络上的每个活动、动作和任务与其他活动动作任务同时存在相互触发。</p><h2 id="4-2-专用过程模型"><a href="#4-2-专用过程模型" class="headerlink" title="4.2 专用过程模型"></a>4.2 专用过程模型</h2><h3 id="4-2-1-基于构件的开发"><a href="#4-2-1-基于构件的开发" class="headerlink" title="4.2.1 基于构件的开发"></a>4.2.1 基于构件的开发</h3><p><strong>基于构建的开发模型</strong>具有许多螺旋模型的特点，它的本质上是演化模型，需要以迭代方式构建网络。不同之处在于基于构建的开发模型<em>采用预先打包的软件构件来开发应用系统</em>（工具？？？），可<strong>复用</strong>。</p><p><strong>步骤如下</strong>：</p><ol><li>对于该问题的应用领域研究和评估可用的基于构件的产品。</li><li>考虑构建集成的问题。</li><li>设计软件架构以容纳这些构建。</li><li>将构件集成到架构中。</li><li>进行充分的测试以保证功能正常</li></ol><h3 id="4-2-2-形式化方法模型"><a href="#4-2-2-形式化方法模型" class="headerlink" title="4.2.2 形式化方法模型"></a>4.2.2 形式化方法模型</h3><p>形式化方法模型的<strong>主要活动</strong>是<em>生成计算机软件形式化的数学规格说明</em>。</p><p>形式化方法使软件开发人员可以应用严格的数学符号来说明、开发和验证基于计算机的系统。应用数学分析的方法，在设计阶段使软件开发人员能发现和改正一些常常被忽略的问题。</p><p><strong>缺点</strong>：</p><ol><li>开发耗时，成本高</li><li>极少程序员具有应用形式化方法的背景，需要大量的培训。</li><li>对于技术水平不高的客户，很难应用这种模型进行沟通。</li></ol><h3 id="4-2-3-面向方面的软件开发-AOP"><a href="#4-2-3-面向方面的软件开发-AOP" class="headerlink" title="4.2.3 面向方面的软件开发 AOP"></a>4.2.3 面向方面的软件开发 AOP</h3><p><strong>横切关注点</strong>：关注点涉及系统多个方面的功能、特性和信息。</p><p>AOP是OOP的延续，是Aspect Oriented Programming的缩写，意思是面向方面编程。AOP实际是GoF设计模式的延续，设计模式孜孜不倦追求的是<strong>调用者和被调用者之间的解耦</strong>，AOP可以说也是这种目标的一种实现</p><h2 id="4-3-统一过程-UP"><a href="#4-3-统一过程-UP" class="headerlink" title="4.3 统一过程 UP"></a>4.3 统一过程 UP</h2><p><img src="https://i.loli.net/2020/03/01/3JSGxNHaBXjOYby.png" alt=""></p><ul><li><p>起始阶段：包括客户沟通和策划活动。该阶段识别基本业务需求，并初步用用例描述每一类用户所需要的主要特性和功能。</p></li><li><p>细化阶段：包括沟通和通用过程模型的建模活动。</p></li><li><p>构建阶段：与通用软件过程中的构建活动相同。</p></li><li><p>转换阶段：包括通用构建活动的后期阶段以及通用部署活动的第一部分。</p></li><li><p>生产阶段：与有通用过程的部署活动一致。</p></li></ul><p>五个阶段不是顺序进行，而是<strong>阶段性并发进行</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程第三章</title>
      <link href="/2020/03/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/2020/03/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程第三章"><a href="#软件工程第三章" class="headerlink" title="软件工程第三章"></a>软件工程第三章</h1><hr><h2 id="3-1-通用过程模型"><a href="#3-1-通用过程模型" class="headerlink" title="3.1 通用过程模型"></a>3.1 通用过程模型</h2><p><strong>过程流</strong>：过程流描述了在执行顺序和执行时间上如何组织框架上的活动、动作和任务。</p><p><strong>线性过程流</strong>：从沟通到部署顺序执行五个框架活动</p><p><strong>迭代过程流</strong>:在执行下一个活动前重复执行之前的一个或多个活动。</p><p><strong>演化过程流</strong>：采用循环的方式执行各个活动，每次循环都能产生更为完善的软件版本。</p><p><strong>并行过程流</strong>：将一个或多个活动与其他活动并行执行<br><img src="https://i.loli.net/2020/03/01/MKom52untCbfSJ7.png" alt=""></p><h2 id="3-2-定义框架活动"><a href="#3-2-定义框架活动" class="headerlink" title="3.2 定义框架活动"></a>3.2 定义框架活动</h2><h2 id="3-3-明确任务集"><a href="#3-3-明确任务集" class="headerlink" title="3.3 明确任务集"></a>3.3 明确任务集</h2><p>任务集定义了为达到一个软件工程工作的目标所需要完成的工作。</p><h2 id="3-4-过程模式"><a href="#3-4-过程模式" class="headerlink" title="3.4 过程模式"></a>3.4 过程模式</h2><p><strong>过程模式</strong>描述了软件工程工作中遇到的过程相关的问题，明确了问题环境并给出了针对该问题的一种或几种可证明的解决方案。</p><p>它更像是提供了一种在软件工程背景下统一描述问题解决问题的方法。<br><em>过程模式提供了描述模式的一般性方法。</em></p><p>以下是Ambler提出的过程模式描述模板：</p><ol><li>模式名称，</li><li>驱动力：模式的使用环境及主要问题</li><li>类型：<ul><li>步骤模式。定义了与过程的框架活动相关的问题</li><li>任务模式。定义了与软件工程动作或是工作任务相关、关系软件工程实践- - 成败的问题</li><li>阶段模式。定义在过程中发生的框架活动序列</li></ul></li><li>启动条件：模式应用的前提条件</li><li>问题</li><li>解决方案</li><li>结果</li><li>已知应用和实例</li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程第二章</title>
      <link href="/2020/03/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2020/03/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程-第二章"><a href="#软件工程-第二章" class="headerlink" title="软件工程 第二章"></a>软件工程 第二章</h1><hr><h2 id="2-1-定义软件工程学科"><a href="#2-1-定义软件工程学科" class="headerlink" title="2.1 定义软件工程学科"></a>2.1 定义软件工程学科</h2><p><strong>软件工程</strong>是：（1）将系统化的、规范的、可量化的方法应用于软件的开发、运行和维护，即将工程化方法应用于软件；（2）对（1）中所述方法的研究。</p><p>软件工程是一种层次化的技术，支持软件工程的<strong>根基在于质量关注点</strong>。<br>软件工程的基础是<strong>过程</strong>层。<br>软件工程<strong>方法</strong>为构建软件提供技术上的解决方案，包括沟通、需求分析、设计建模、程序构造、测试和技术支持。<br>软件工程<strong>工具</strong>为过程和方法提供自动化或半自动化的支持。<br><img src="https://i.loli.net/2020/03/01/oWwZxCsXkdQ9GnY.png" alt=""></p><h2 id="2-2-软件过程"><a href="#2-2-软件过程" class="headerlink" title="2.2 软件过程"></a>2.2 软件过程</h2><p><strong>软件过程</strong>是工作产品构建时所执行的一系列活动、动作和任务的集合。</p><h3 id="2-2-1-过程框架"><a href="#2-2-1-过程框架" class="headerlink" title="2.2.1 过程框架"></a>2.2.1 过程框架</h3><p>一个通用的软件工程过程框架通常包含以下五个活动：</p><ul><li><strong>沟通</strong></li><li><strong>策划</strong></li><li><strong>建模</strong></li><li><strong>构建</strong></li><li><strong>部署</strong></li></ul><h3 id="2-2-2-普适性活动"><a href="#2-2-2-普适性活动" class="headerlink" title="2.2.2 普适性活动"></a>2.2.2 普适性活动</h3><ul><li><strong>软件项目跟踪和控制</strong></li><li><strong>风险管理</strong></li><li><strong>软件质量保证</strong></li><li><strong>技术评审</strong></li><li><strong>测量</strong></li><li><strong>软件配置管理</strong></li><li><strong>可复用管理</strong></li><li><strong>工作产品的准备和生产</strong></li></ul><h2 id="2-3-软件工程实践"><a href="#2-3-软件工程实践" class="headerlink" title="2.3 软件工程实践"></a>2.3 软件工程实践</h2><h3 id="2-3-1-实践的精髓"><a href="#2-3-1-实践的精髓" class="headerlink" title="2.3.1 实践的精髓"></a>2.3.1 实践的精髓</h3><p>-<strong>理解问题</strong><br>-<strong>策划解决方案</strong><br>-<strong>实施计划</strong><br>-<strong>检查结果</strong></p><h3 id="2-3-2-通用原则"><a href="#2-3-2-通用原则" class="headerlink" title="2.3.2 通用原则"></a>2.3.2 通用原则</h3><p>第一原则<strong>存在价值</strong>：为用户提供价值而具有存在价值<br>第二原则<strong>保持简洁</strong>：所有设计都应尽可能简洁，但不是过于简化。有助于构建更易于理解和维护的系统。<br>第三原则<strong>保持愿景</strong>：清晰的愿景是软件项目成功的基础。<br>第四原则<strong>关注使用者</strong><br>第五原则<strong>面向未来</strong>：为各种可能的方案做好准备，提高整个系统的可复用性<br>第六原则<strong>提前计划复用</strong>：提前做好服用计划将降低开发费用，并增加可复用构件以及构建化系统的价值<br>第七原则<strong>认真思考</strong></p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统概念第七章</title>
      <link href="/2020/02/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
      <url>/2020/02/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="7数据库设计和E-R模型"><a href="#7数据库设计和E-R模型" class="headerlink" title="7数据库设计和E-R模型#"></a>7数据库设计和E-R模型#</h1><hr><h2 id="7-1设计过程概览"><a href="#7-1设计过程概览" class="headerlink" title="7.1设计过程概览"></a>7.1设计过程概览</h2><h3 id="7-1-1-设计阶段"><a href="#7-1-1-设计阶段" class="headerlink" title="7.1.1 设计阶段"></a>7.1.1 设计阶段</h3><ul><li><p>数据库设计的最初阶段需要完整地刻画未来数据用户的数据需求。</p></li><li><p>接下来，设计者选择数据模型，并采用所选数据模型的概念将这些需求转化为数据库的概念模式。我们在本章中将研究的实体-联系模型通常用于表示概念设计。<strong>概念模式</strong>定义了数据库中表示的实体、实体的属性、实体之间的联系、以及实体和联系上的约束。通常，概念设计阶段会导致E-R图的构建，它提供了对模式的图形化描述。</p></li><li><p>完善的概念模式还指明企业的功能需求。在功能需求规格说明中，用户描述将在数据上进行的各类操作。（增删改查）</p></li><li><p>从抽象数据模型到数据库实现的转化过程在最后两个设计阶段中进行。</p><ul><li><p>在逻辑设计阶段，设计者将高层概念模式隐射到将使用的数据库系统的实现数据模型上。</p></li><li><p>最后，设计者将所得到的系统特定的数据库模式使用到后续的物理设计阶段。</p></li></ul></li></ul><h3 id="7-1-2-设计选择"><a href="#7-1-2-设计选择" class="headerlink" title="7.1.2 设计选择"></a>7.1.2 设计选择</h3><p>实体：指明所有可明确识别的个体。</p><p>在设计一个数据库模式的时候，我们必须确保避免两个主要缺陷：<em>冗余，不完整。</em></p><h2 id="E-R-模型"><a href="#E-R-模型" class="headerlink" title="E-R 模型"></a>E-R 模型</h2><h3 id="7-2-1-实体集"><a href="#7-2-1-实体集" class="headerlink" title="7.2.1 实体集"></a>7.2.1 实体集</h3><p><strong>实体</strong>：现实世界中可区别于所有其他对象的一个“事物”或“对象”。</p><p><strong>实体集</strong>：相同类型即具有相同性质（或属性）的一个实体集合。<br><img src="https://i.loli.net/2020/02/29/1f6rqBDXdU8j5Ho.png" alt=""></p><p>在建模的过程中，我们通常抽象地使用术语实体集，而不是指某个个别实体的特别集合。我们用术语实体集的<strong>外延</strong>来指属于实体集的实体的实际集合。</p><p>实体通过一组<strong>属性</strong>来表示。属性是实体集中每个成员所拥有的描述性性质。但每个实体在每个属性上都有各自的值。</p><h3 id="7-2-2-联系集"><a href="#7-2-2-联系集" class="headerlink" title="7.2.2 联系集"></a>7.2.2 联系集</h3><p><strong>联系</strong>：指多个实体间的相互关联。</p><p><strong>联系集</strong> ：相同类型联系的集合。</p><p><img src="https://i.loli.net/2020/02/29/ZIcEVtPFYnmSAbU.png" alt=""><br><strong>参与</strong>：实体集之间的关联，也就是说实体集E1，E2…参与联系集R。<br><strong>角色</strong>：实体在联系中扮演的功能。当参与联系集的实体集并非互异的时候，也就是说同样的实体集以不同的角色参与一个联系集多于一次，在这一类联系集中，即有时称作<strong>自环的</strong>联系集中，有必要用显式的角色名来指明实体是如何参与联系实例的。<br>联系也可以具有<strong>描述性属性</strong>。给定的联系集中的一个联系实例必须是由其参与实体唯一标识的，而不必使用描述属性。<br><img src="https://i.loli.net/2020/02/29/TzYagME7rKSDloh.png" alt=""></p><h3 id="7-2-3-属性"><a href="#7-2-3-属性" class="headerlink" title="7.2.3 属性"></a>7.2.3 属性</h3><p>每个属性都有一个可取值的集合，称为该属性的<strong>域</strong>，或者<strong>值集</strong>。正规地说，实体集的属性是将实体集映射到于的函数。</p><p>由于一个实体集可能有多个属性，因此每个实体可以用一组（属性，数据值）来表示，实体集的每个属性对应一个这样的对。</p><p>E-R模型中的属性可以按照如下的属性类型来进行划分：</p><ul><li><strong>简单和复合属性</strong>：简单属性不能划分为更小的部分，复合属性可以再划分为更小的部分。</li><li><strong>单值和多值属性</strong>：为了表示一个属性是多值的，我们用花括号将属性名括住，例如：{phone_number}。在适当的情况下，可以对一个多值属性的取值数目设置上、下界。</li><li><strong>派生属性</strong>：这类属性的值可以从别的相关属性或实体派生出来。例如：age和date_of_birth。</li></ul><p>当实体在某个属性上没有值时，使用空值Null。可以表示缺失未知不适用。</p><h2 id="7-3-约束"><a href="#7-3-约束" class="headerlink" title="7.3 约束"></a>7.3 约束</h2><h3 id="7-3-1-映射基数"><a href="#7-3-1-映射基数" class="headerlink" title="7.3.1 映射基数"></a>7.3.1 映射基数</h3><p>** 映射基数 **，或基数比率，表示一个实体通过一个联系集能关联的实体的个数。（一对一，一对多，多对一，多对多）<br><img src="https://i.loli.net/2020/02/29/s9TU4pnburRvFPi.png" alt=""></p><h3 id="7-3-2-参与约束"><a href="#7-3-2-参与约束" class="headerlink" title="7.3.2 参与约束"></a>7.3.2 参与约束</h3><p>如果实体集E中的每个实体都参与到联系集R的至少一个联系中，实体集E在联系集R中的参与称为<strong>全部</strong>的。</p><p>如果E只有部分实体参与到R的联系中，实体集E到联系集R的参与称为<strong>部分</strong>的。</p><h3 id="7-3-3-码"><a href="#7-3-3-码" class="headerlink" title="7.3.3 码"></a>7.3.3 码</h3><p>码是数据系统中的基本概念。所谓码就是能唯一标识实体的属性，他是整个实体集的性质，而不是单个实体的性质。它包括<em>超码，候选码，主码</em>。码同样用于唯一地标识联系，并从而将联系互相分开。</p><p><strong>超码</strong>是一个或多个属性的集合，这些属性可以让我们在一个实体集中唯一地标识一个实体。如果K是一个超码，那么K的任意超集也是超码，也就是说如果K是超码，那么所有包含K的集合也是超码。　</p><p><strong>候选码</strong>是从超码中选出的，自然地候选码也是一个或多个属性的集合。因为超码的范围太广，很多是我们并不感兴趣即无用处的。所以候选码是最小超码，它们的任意真子集都不能成为超码。</p><p><strong>主码</strong>：被数据库设计者选中的，用来在同一实体集中区分不同实体的候选码；此外，应该选择哪些从不或极少变化的属性</p><h2 id="7-4-从实体集中删除冗余属性"><a href="#7-4-从实体集中删除冗余属性" class="headerlink" title="7.4 从实体集中删除冗余属性"></a>7.4 从实体集中删除冗余属性</h2><h2 id="7-5-E-R联系图"><a href="#7-5-E-R联系图" class="headerlink" title="7.5 E-R联系图"></a>7.5 E-R联系图</h2><h3 id="7-5-1-基本结构"><a href="#7-5-1-基本结构" class="headerlink" title="7.5.1 基本结构"></a>7.5.1 基本结构</h3><p>E-R图包括如下几个主要构件：</p><ul><li><strong>分成两部分的矩形</strong>代表实体集。</li><li><strong>菱形</strong>代表联系集。</li><li><strong>未分割的矩形</strong>代表联系集的属性</li><li><strong>线段</strong>将实体集连接到联系集。</li><li><strong>虚线</strong>将联系集属性连接到联系集。</li><li><strong>双线</strong>显示实体在联系集中的参与度。</li><li><strong>双菱形</strong>代表连接到弱实体集的标志性联系集。<br><img src="https://i.loli.net/2020/02/29/nUOL6NXqA84TsRZ.png" alt=""></li></ul><h3 id="7-5-2-映射函数"><a href="#7-5-2-映射函数" class="headerlink" title="7.5.2 映射函数"></a>7.5.2 映射函数</h3><p><img src="https://i.loli.net/2020/02/29/fHgdpsqQlbYt2RI.png" alt=""></p><p>A-&gt;B表示一个A对应一个B，A-B表示一个A对应多个B </p><p>E-R图还提供了一种描述每个实体参与联系集中的联系的次数的更复杂的约束方法。实体集和二元联系集之间的一条边可以有一个关联的最大和最小的映射函数，用<strong>l…h</strong>的形式表示。l表示最小映射函数，h表示最大映射函数，*表示没有限制。</p><h3 id="7-5-4-角色"><a href="#7-5-4-角色" class="headerlink" title="7.5.4 角色"></a>7.5.4 角色</h3><p>在E-R图中，我们通过在菱形和矩形之间的连线上进行标注来表示角色。</p><h3 id="7-5-5-非二元的联系集"><a href="#7-5-5-非二元的联系集" class="headerlink" title="7.5.5 非二元的联系集"></a>7.5.5 非二元的联系集</h3><h3 id="7-5-6-弱实体集"><a href="#7-5-6-弱实体集" class="headerlink" title="7.5.6 弱实体集"></a>7.5.6 弱实体集</h3><p>没有足够的属性以形成主码的实体集称为<strong>弱实体集</strong>，有主码的实体集称作<strong>强实体集</strong>。</p><p>弱实体集必须与另一个称作<strong>标识</strong>或<strong>属主实体集</strong>的实体集关联才能有意义。即，<em>弱实体集存在依赖于标识实体集</em>，我们称标识实体集<strong>拥有</strong>它所标识的弱实体集。将弱实体集与其标识实体集相连的联系称为<strong>标识性联系</strong>。</p><p>弱实体集的<strong>分辨符</strong>使得我们进行区分依赖于特定强实体集的弱实体集中的实体的属性集合。</p><p><img src="https://i.loli.net/2020/02/29/34s8ZRk6pyBJfSe.png" alt=""></p><h2 id="7-7-3-二元还是N元联系集"><a href="#7-7-3-二元还是N元联系集" class="headerlink" title="7.7.3 二元还是N元联系集"></a>7.7.3 二元还是N元联系集</h2><p>事实上，一个非二元的(n元，n&gt;2)联系集总可以用一组不同的二元联系集来替代。简单起见，考虑一个抽象的三元联系集R，它将实体集A、B和C联系起来。用实体集E替代联系集R,并创建三个联系集，如图：<br><img src="https://i.loli.net/2020/03/01/D6mpRrZcilM3n51.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统概念第一章</title>
      <link href="/2020/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2020/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库系统概念第一章"><a href="#数据库系统概念第一章" class="headerlink" title="数据库系统概念第一章"></a>数据库系统概念第一章</h1><hr><p><strong>数据库管理系统DBMS：</strong> 由一个相互关联的数据的集合（即<strong>数据库DB</strong>）和一组用以访问这些数据的程序组成。         </p><p><strong>数据抽象：</strong>           </p><ul><li><strong>物理层</strong>：最低层次的抽象，描述数据实际上是怎样存储的。物理层详细描述复杂的底层数据结构             </li><li><strong>逻辑层</strong>：比物理层层次稍高的抽象，描述数据库中存储什么数据及这些数据间存在什么关系。虽然逻辑层的简单结构的实现可能涉及复杂的物理层结构，但逻辑层用户不必知道这样的复杂性，这称作<strong>物理数据独立性</strong>。数据库管理员使用抽象的逻辑层，他必须确定数据库中应该保存哪些信息。           </li><li><strong>视图层</strong>：最高层次的抽象，只描述整个数据库的某个部分。数据库系统的很多用户并不需要关心所有的信息，而只需要访问数据库的一部分。系统可以为同一数据库提供多个视图。<br><img src="https://i.loli.net/2020/02/22/hOdi5Qk2T94YXKu.png" alt=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
