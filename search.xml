<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java_程序设计基础</title>
      <link href="/2020/03/02/java-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/03/02/java-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA-程序设计基础"><a href="#JAVA-程序设计基础" class="headerlink" title="JAVA_程序设计基础"></a>JAVA_程序设计基础</h1><hr><h2 id="标识符、关键字、注释、常量变量"><a href="#标识符、关键字、注释、常量变量" class="headerlink" title="标识符、关键字、注释、常量变量##"></a>标识符、关键字、注释、常量变量##</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p><strong>标识符</strong>：为程序中的各个元素（如变量、类名、对象名）进行命名。</p><p>一般地，在Java 中标识符是以<strong>字母、下划线（_）、美元符号（$）</strong>等开始的一个字符序列，后面可以跟字母、下划线、美元符号、数字等字符。所以，<strong>不能以数字开始</strong>，但其他位置可以使用 </p><p><em>标识符是大小写敏感的，不能和关键字相同</em> </p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>所有的关键字都是<strong>小写</strong>的。</p><ul><li>包相关关键字：package   import</li><li>用于数据类型的关键字：byte   short  int   long  float double  char   boolean</li><li>用于流程控制语句的关键字：if  else  switch  case  default  do  while  for  break  continue</li><li>方法、类型、变量的修饰关键字：private   public  protected   final  static   abstract   synchronized   volatile</li><li>异常处理关键字：try  catch  finally  throw  throws</li><li>对象相关关键字：new  extends  implements  class  instanceof  this  super</li><li>字面值常量关键字：false   true    null</li><li>方法相关关键字：return   void</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行注释：单行注释以“//”开头，至该行结尾<br>多行注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  注释文本</span></span><br><span class="line"><span class="comment">   ……</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>文档注释:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**注释文本</span></span><br><span class="line"><span class="comment">*注释文本</span></span><br><span class="line"><span class="comment">*……</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>该类注释可通过jdk下的javadoc.exe程序提取并自动为代码生成文档，Java API文档也是通过这种方式生成。</p><h3 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h3><p>变量<strong>定义</strong>：[修饰符] &lt;类型名&gt;  &lt;变量名&gt; [=&lt;初值&gt;][,&lt;变量名&gt;[=&lt;初值&gt;]…]； </p><ul><li>例如：int i；int j=5，k=4;</li></ul><p>按作用域可以将变量大致分为： </p><ul><li><strong>局部变量</strong>是在方法内部或代码块中声明的变量，它的作用域为所在的代码块，在程序中，以“{ …… }”为界。 </li><li><strong>类成员变量</strong>，它的作用域是整个类。</li><li><strong>方法参数</strong>的作用域，是所在的方法 </li></ul><p><strong>常量定义</strong>：变量定义前加<strong>final关键字</strong>即可。<br>final int NUMBER=100;<br>final int MAX_LOOP=5;<br>常量命名规范：<strong>常量名全部大写</strong></p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><img src="https://i.loli.net/2020/03/02/Vd4N8lseWBj21LM.png" alt=""></p><p>###整数类型 ###</p><table><thead><tr><th>数据类型</th><th>所占位数</th><th>数的范围</th></tr></thead><tbody><tr><td>byte</td><td>8</td><td>-2^7 ～(2^7 -1)</td></tr><tr><td>short</td><td>16</td><td>-2^15 ～(2^15 -1)</td></tr><tr><td>int</td><td>32</td><td>-2^31 ～(2^31 -1)</td></tr><tr><td>long</td><td>64</td><td>-2^63 ～(2^63-1)</td></tr></tbody></table><p><strong>Java中的整数都用二进制的补码表示</strong>。<br>原码：最高位为符号位，正数时为0，负数时为1。<br>补码: 非负数的补码就是原码；负数的补码是将其对应正数的原码按位取反再加1。</p><p>表示<strong>long</strong>型常量时，需在数字后面<strong>加上后缀L或l</strong>。例如3L表示一个long型的常量，而不是int型。</p><p>Java的基本数据类型都有固定的数据位，不随运行平台的变化而变化。计算时注意可能产生的溢出。</p><p>Java中的整数有三种进制表示：<br>十进制：用0<del>9的数值表示，<strong>首位不能为0</strong>，例如：124，-100；<br>八进制：<strong>以0开头</strong>，后跟多个0</del>7之间的数字，如0134；<br>十六进制：<strong>以0x或者0X开头</strong>，后跟多个0<del>9之间的数字、或A</del>F之间的的大写字、或者a<del>f之间的小写字母。a</del>f或者A-F分别表示10~15，例如，0x10，等于十进制数16。</p><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>Java中，字符类型char用16位的<strong>Unicode</strong>码表示。<br>同c语言，<strong>字符常量用单引号包围表示</strong>，如 ’a’；<br>Unicode是一个编码方案，表示了0到65535的整数与65536个字符间的匹配关系，比如49为字符’1’ ，65为字符’A’ ， 19968为汉字字符’一’。 ASCII码基于拉丁字母只定义了128个字符。</p><table><thead><tr><th>转义字符</th><th>描述</th></tr></thead><tbody><tr><td>\uxxxx</td><td>1到4位16进制数所表示的字符(xxxx)</td></tr><tr><td>\</td><td>反斜杠</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\t</td><td>横向跳格</td></tr></tbody></table><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><table><thead><tr><th>数据类型</th><th>所占位数</th><th>数的范围</th></tr></thead><tbody><tr><td>float（单精度浮点数）</td><td>32</td><td>3.4e-038 ～3.4e+038</td></tr><tr><td>double（双精度浮点数）</td><td>64</td><td>1.7e-308 ～ 1.7e+308</td></tr></tbody></table><p>用IEEE 754 标准将二进制表示成浮点数<br>比如32位的float分成三个区域：1位的符号位s、8位的指数位e、23位的有效数位f。<br>一个浮点数默认为double型。<strong>在一个浮点数后加字母F或f</strong>，表示float型。</p><ul><li>常数3.45的类型是double；3.45F的类型是float。</li></ul><h3 id="各类型数据间的相互转换"><a href="#各类型数据间的相互转换" class="headerlink" title="各类型数据间的相互转换"></a>各类型数据间的相互转换</h3><ul><li><p><strong>自动类型转换</strong>：从表达范围小的类型向表达范围大的类型发生自动类型转换<br>  范围由小到大：byte，short/char, int, long, float, double<br>  byte, short, char类型进行运算时会自动转换为int类型</p></li><li><p>** 强制类型转换**：由表达范围大的向小的类型转换时，需要强制类型转换；因为此时可能会发生数据截断。</p></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>|运算符|    用法    |含义    |结合性|<br>|——|——|——|——|——|<br>|    +    |op1+op2    |加法    |左|<br>|-|    op1-op2    |减法|    左|<br>|*    |op1*op2    |乘法    |左|<br>|/    |op1/op2    |除法    |左|<br>|%    |op1%op2    |模运算(求余)|    左|<br>|+    |+op1    |正数    |右|<br>|-    |-op1    |负数    |右|<br>|++    |++op1,op1++    |自增|    右，左|<br>|–    |–op1, op1–    |自减|    右，左|</p><ul><li>对于二元运算符，运算结果的数据类型为两个操作数中表达范围较大的类型。例如，<br>一个int和double运算的结果为double。对于一元运算符，运算结果的类型与操作数的类型相同</li></ul><p>自增、自减运算符有前缀和后缀两种形式，</p><ul><li>当是前缀形式（即++、–符号出现在变量的左侧）时，对变量实施的运算是“<strong>先运算后使用</strong>”； </li><li>当是后缀形式时，对变量实施的运算是“<strong>先使用后运算</strong></li></ul><p>再次强调：byte，short，char等类型进行算数运算时，会先自动转换为int类型再运算。</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table><thead><tr><th>运算符</th><th>示例</th><th>含义</th></tr></thead><tbody><tr><td>=</td><td>count = 2</td><td>count变量赋值为2</td></tr><tr><td>+=</td><td>count += 2</td><td>count = count + 2</td></tr><tr><td>-=</td><td>count -= 2</td><td>count = count - 2</td></tr><tr><td>*=</td><td>count *= 2</td><td>count = count * 2</td></tr><tr><td>/=</td><td>count /= 2</td><td>count = count / 2</td></tr><tr><td>%=</td><td>count %= 2</td><td>count = count % 2</td></tr></tbody></table><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(boolean_expr) ?  </span><br><span class="line">true_statement : false_statement；</span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>Java中，boolean（布尔）类型的数据只有两种取值：true、false</p><p>逻辑运算只能处理布尔类型的数据，所得结果也是布尔值 </p><p>运算优先级：非&gt;与&gt;或 </p><table><thead><tr><th>运算符</th><th>示例</th><th>含义</th><th>结合性</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>Op1 &amp;&amp; Op2</td><td>逻辑与运算：仅当两个运算符的值都为true时结果为true</td><td>左</td></tr><tr><td>&#124; &#124;</td><td>Op1 &#124;&#124; Op2</td><td>逻辑或运算：两个运算符中若有其一值为true则结果为true</td><td>左</td></tr><tr><td>!</td><td>! Op</td><td>逻辑非运算：!true=false, !flase=true</td><td>右</td></tr></tbody></table><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ul><li>&amp;，示例“Op1  &amp;  Op2”，表示使Op1和Op2按位相与</li><li>|，示例“Op1  |  Op2”，表示使Op1和Op2按位相或</li><li>~ ，示例“~Op1”，表示对Op按位取反</li><li>^，示例“Op1 ^ Op2”，表示使Op1和Op2按位异或</li><li>‘&lt;&lt;’，示例“Op1 &lt;&lt;  Op2”，使Op1左移Op2位，右补0</li><li>‘&gt;&gt;’，示例“Op1 &gt;&gt;  Op2”，使Op1右移Op2位(带符号，左边补充符号位)</li><li>‘&gt;&gt;&gt;’，示例“Op1 &gt;&gt;&gt;  Op2”,使Op1无符号右移Op2位(左边始终补添0)</li></ul><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p><strong>表达式</strong>是程序设计语言的基本组成部分，表示一种求值的规则，是由运算符和操作数组成的符号序列。</p><p>在对表达式进行运算时，遵循一定的规则，要按<strong>运算符的优先级</strong>从高到低进行，同级的运算符则按从左到右的方向进行。</p><p>以下符号优先级从高到低排列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.. [] () ++ -- ! ~ </span><br><span class="line">2.new (type) </span><br><span class="line">3.* &#x2F; %     </span><br><span class="line">4.+ -   </span><br><span class="line">5.&gt;&gt;  &gt;&gt;&gt;  &lt;&lt;       </span><br><span class="line">6.&lt; &gt; &lt;&#x3D; &gt;&#x3D;   </span><br><span class="line">7.&#x3D;&#x3D; !&#x3D;     </span><br><span class="line">8.&amp;  </span><br><span class="line">9.^ </span><br><span class="line">10.|    </span><br><span class="line">11.&amp;&amp; </span><br><span class="line">12.|| </span><br><span class="line">13.? :</span><br><span class="line">14.&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; ^&#x3D;</span><br><span class="line">15.&amp;&#x3D;  &lt;&lt;&#x3D; &gt;&gt;&#x3D; &gt;&gt;&gt;&#x3D;</span><br></pre></td></tr></table></figure><h2 id="程序控制语句"><a href="#程序控制语句" class="headerlink" title="程序控制语句"></a>程序控制语句</h2><h3 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h3><p>Java中的选择语句包括：if语句和switch语句。</p><p><strong>if语句</strong>:</p><p>条件condition可以是任何返回布尔值的表达式。条件为真时执行语句statement1，假时执行statement2。else子句是可选的。</p><p>statement1和2可以是单个语句，也可以是程序块。后者必须加大括号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition) </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(condition)        </span><br><span class="line">statement;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      statement; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">      statement</span><br></pre></td></tr></table></figure><p><strong>switch语句</strong>:</p><p>表达式expression返回的类型必须为<strong>byte，short，int，char</strong>，或者<strong>字符串</strong>。</p><p>每个case语句后的值必须是与表达式类型兼容的特定的一个常量</p><p>一旦case匹配，就会顺序执行后面的程序代码，直到遇见break。<br>如果没有一个case常量与表达式的值匹配，则执行default语句(可选)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line"><span class="keyword">case</span> value1:</span><br><span class="line">      ... <span class="comment">// 语句序列</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> value2:</span><br><span class="line">      ... <span class="comment">//语句序列</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> valueN:</span><br><span class="line">      ... <span class="comment">//语句序列</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">      ... <span class="comment">//语句序列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p><strong>while语句</strong><br>循环语句，当它的条件表达式是true时，while语句重复执行循环体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>do-while语句</strong><br>do-while循环总是先执行循环体，然后再计算条件表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">  &#x2F;&#x2F; 循环体</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">while(condition);</span><br></pre></td></tr></table></figure><p><strong>for语句</strong></p><ol><li>执行初始化部分；</li><li>计算条件condition的值；</li><li>若为true，则执行循环体，之后执行迭代iteration部分，然后跳转到第二步；</li><li>若为false，则循环终止</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(initialization; condition; iteration) &#123;</span><br><span class="line">      ... &#x2F;&#x2F; 循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3><p>跳转语句包括：</p><ul><li>return语句</li><li>break语句</li><li>continue语句</li></ul><p><strong>return语句</strong>用来明确地从一个方法返回：<br>若返回一个值，其格式如下： return 返回值;<br>若无返回值，则直接： return ; </p><p><strong>使用break</strong> 退出循环语句或switch语句</p><p><strong>使用continue</strong>终止循环的本次迭代继续进入下一次迭代</p><p><strong>带标记的break &amp; continue</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">outer: <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (j &gt; i) &#123;</span><br><span class="line">                   System.out.println();</span><br><span class="line">                   <span class="keyword">continue</span> outer;</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.print(<span class="string">" "</span> + (i * j));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br></pre></td></tr></table></figure><ul><li>针对标记处的程序行break或continue，该语法类似goto 的功能</li><li>仅建议在继续或退出双重以上循环时使用</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程第四章</title>
      <link href="/2020/03/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
      <url>/2020/03/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程第四章"><a href="#软件工程第四章" class="headerlink" title="软件工程第四章"></a>软件工程第四章</h1><hr><h2 id="4-1-惯用过程模型"><a href="#4-1-惯用过程模型" class="headerlink" title="4.1 惯用过程模型"></a>4.1 惯用过程模型</h2><h3 id="4-1-1-瀑布模型"><a href="#4-1-1-瀑布模型" class="headerlink" title="4.1.1 瀑布模型"></a>4.1.1 瀑布模型</h3><p><strong>瀑布模型</strong>又称为经典生命周期，它提出了一个系统的、顺序的软件开发方法，从用户需求规格说明开始，通过策划、建模、构建和部署的过程，最终提供完整的软件支持。(可能会导致任务阻塞)<br><img src="https://i.loli.net/2020/03/01/DvhEQI4aSY2JBwU.png" alt=""></p><p><strong>V模型</strong>（瀑布模型的变体），随着软件团队工作沿着V模型左侧步骤向下推进，基本问题需求逐步细化，形成了对问题及解决方案详尽且技术性的描述。一旦编码结束，团队沿着V模型右侧的步骤向上推进工作，其本质上是执行了一系列测试。<br><img src="https://i.loli.net/2020/03/01/Hrf7lOutVsJjiBU.png" alt=""></p><p><strong>优点</strong>：</p><ol><li>强调开发的阶段性，各阶段具有顺序性和依赖性</li><li>强调早期调研和需求分析，推迟编码实现的观点</li><li>提供了一个摸板，这个摸板使得分析、设计、编码、测试和支持的方法可以 在该摸板下有一个共同的指导</li></ol><p><strong>缺点</strong>：<br>2. 文档驱动，用户无法及时了解产品的情况<br>2. 依赖早期调研和需求分析，很难适应在许多项目开始阶段必然存在的不确定性。<br>2.  流程单一，必须要完成前一阶段的任务，才能进行下一阶段，开发过程中的 成功经验无法用于本产品。<br>2.  测试在后期引入，对于系统存在的重大缺陷，如果在可执行程序评审之前没有被发现，将可能造成重大损失。<br>2. 组织庞大，人员闲置。<br>3. </p><h3 id="4-1-2-增量过程模型"><a href="#4-1-2-增量过程模型" class="headerlink" title="4.1.2 增量过程模型"></a>4.1.2 增量过程模型</h3><p><img src="https://i.loli.net/2020/03/01/YazXpleMQNf42F8.png" alt=""><br>该模型综合了线性过程流和并行过程流的特征。增量过程模型<strong>以迭代的方式运用瀑布模型</strong>，把软件产品作为一系列的增量构件来设计、编码、集成和测试。</p><p>每个构件由多个相互作用的模块构成，并且能够完成特定的功能。使用增量模型时，<em>第一个增量往往是核心功能</em>。</p><p>我感觉类似于计算机组成原理中的流水线，随着时间的推移，增量模型在每个阶段都运用线性序列。每个线性序列生产出软件的可交付增量。</p><p><strong>优点</strong>：<br>3. 能在较短的时间内向用户提交可完成部分工作的产品。<br>3. 逐步增加产品功能可以使用户有充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。<br>3. 规避技术风险<br>3. 可并行开发构件，加快开发的进度</p><p><strong>缺点</strong>：<br>4.  没有考虑软件的整体质量和长期的可维护性。<br>4.  大部分情况是不合适的操作算法被采用目的为了演示功能，不合适的开发工具被采用仅仅为了它的方便，还有不合适的操作系统被选择等等。<br>4.  由于达不到质量要求产品可能被抛弃，而采用新的模型重新设计</p><h3 id="4-1-3-演化过程模型"><a href="#4-1-3-演化过程模型" class="headerlink" title="4.1.3 演化过程模型"></a>4.1.3 演化过程模型</h3><p>演化模型是迭代的过程模型，以下是两种常用的演化过程模型：</p><p><strong>原型开发</strong>：</p><ul><li>从需求收集开始，开发者和客户在一起定义软件的总体目标，标识已知的需求并且规划出需要进一步定义的区域。</li><li>然后是“快速设计”，它集中于软件中那些对客户可见的部分的表示，这将导致原型的创建，并由客户评估并进一步精化待开发软件的需求。</li><li>逐步调整原型使其满足客户的需求，这个过程是迭代的。其流程从听取客户意见开始、随后是建造/修改原型、客户测试运行原型、然后回头往复循环直到客户对原型满意为止。</li></ul><p><img src="https://i.loli.net/2020/03/01/ntUPMFxRNfvHuj3.png" alt=""></p><p><strong>优点</strong>：<br>5. 能让人（开发者或客户很快见到产品，有成就感。<br>5. 能渐进地启发客户提出新的要求或任务。</p><p><strong>缺点</strong>：<br>6. 没有考虑软件的整体质量和长期的可维护性。<br>6. 大部分情况是不合适的操作算法被采用目的为了演示功能，不合适的开发工具被采用仅仅为了它的方便，还有不合适的操作系统被选择等等。<br>6. 由于达不到质量要求产品可能被抛弃，而采用新的模型重新设计。</p><hr><p><strong>螺旋模型</strong>：</p><p>螺旋模型是一种<strong>演进式软件过程模型</strong>，结合了原型的迭代性质和瀑布模型的系统性和可控性的特点，具有快速开发越来越完善软件版本的潜力。</p><p>螺旋模型是一种<strong>风险驱动型</strong>的过程模型生成器，对于软件集中的系统，它可以指导多个利益相关者的协同工作。它有两个显著特点：</p><ol><li>采用<strong>循环的方式</strong>逐步加深系统定义和实现的深度，同时降低风险。</li><li>二是确定一系列<strong>里程碑</strong>作为支撑点，确保利益相关者认可是可行的且可令各方满意的系统解决方案。</li></ol><p>开发步骤：沿螺线自内向外，每旋转一圈便开发出更为完善的一个新的软件版本。</p><p>例如，在第一圈，确定了初步的目标、方案和限制条件以后，转入右上象限，对风险进行识别和分析。如果风险分析表明，需求有不确定性，那么在右下的工程象限内，所建的原型会帮助开发人员和客户，考虑其它开发模型，并对需求做进一步修正。客户对工程成果做出评价之后，给出修正建议。在此基础上需再次计划，并进行风险分析。在每一圈螺线上，风险分析的终点做出是否继续下去的判断。假如风险过大，开发者和用户无法承受，项目有可能终止。多数情况下沿螺线的活动会继续下去，自内向外，逐步延伸，最终得到所期望的系统。</p><p><img src="https://i.loli.net/2020/03/01/Moms8wUy6ktR4ax.png" alt=""></p><p><strong>优点</strong>：</p><ol><li>强调风险</li><li>强调阶段质量</li><li>提供纠错的机会</li></ol><p><strong>缺点</strong>：</p><ol><li>每个阶段都要提出被选方案，进行风险分析，研发周期长，效率低</li><li>必须要转业的风险分析人员的参与</li></ol><h3 id="4-1-4-并发模型"><a href="#4-1-4-并发模型" class="headerlink" title="4.1.4 并发模型"></a>4.1.4 并发模型</h3><p>也叫做<strong>并发工程</strong>，它允许软件团队表述本章所描述的任何过程模型中的迭代元素和并发元素。<br><img src="https://i.loli.net/2020/03/01/h4wPs16loG3eV8y.png" alt=""></p><p>(很像操作系统对进程管理的感觉)</p><p>它不是把软件工程活动、动作和任务局限在一个事件的序列，而是定义了一个<strong>过程网络</strong>，网络上的每个活动、动作和任务与其他活动动作任务同时存在相互触发。</p><h2 id="4-2-专用过程模型"><a href="#4-2-专用过程模型" class="headerlink" title="4.2 专用过程模型"></a>4.2 专用过程模型</h2><h3 id="4-2-1-基于构件的开发"><a href="#4-2-1-基于构件的开发" class="headerlink" title="4.2.1 基于构件的开发"></a>4.2.1 基于构件的开发</h3><p><strong>基于构建的开发模型</strong>具有许多螺旋模型的特点，它的本质上是演化模型，需要以迭代方式构建网络。不同之处在于基于构建的开发模型<em>采用预先打包的软件构件来开发应用系统</em>（工具？？？），可<strong>复用</strong>。</p><p><strong>步骤如下</strong>：</p><ol><li>对于该问题的应用领域研究和评估可用的基于构件的产品。</li><li>考虑构建集成的问题。</li><li>设计软件架构以容纳这些构建。</li><li>将构件集成到架构中。</li><li>进行充分的测试以保证功能正常</li></ol><h3 id="4-2-2-形式化方法模型"><a href="#4-2-2-形式化方法模型" class="headerlink" title="4.2.2 形式化方法模型"></a>4.2.2 形式化方法模型</h3><p>形式化方法模型的<strong>主要活动</strong>是<em>生成计算机软件形式化的数学规格说明</em>。</p><p>形式化方法使软件开发人员可以应用严格的数学符号来说明、开发和验证基于计算机的系统。应用数学分析的方法，在设计阶段使软件开发人员能发现和改正一些常常被忽略的问题。</p><p><strong>缺点</strong>：</p><ol><li>开发耗时，成本高</li><li>极少程序员具有应用形式化方法的背景，需要大量的培训。</li><li>对于技术水平不高的客户，很难应用这种模型进行沟通。</li></ol><h3 id="4-2-3-面向方面的软件开发-AOP"><a href="#4-2-3-面向方面的软件开发-AOP" class="headerlink" title="4.2.3 面向方面的软件开发 AOP"></a>4.2.3 面向方面的软件开发 AOP</h3><p><strong>横切关注点</strong>：关注点涉及系统多个方面的功能、特性和信息。</p><p>AOP是OOP的延续，是Aspect Oriented Programming的缩写，意思是面向方面编程。AOP实际是GoF设计模式的延续，设计模式孜孜不倦追求的是<strong>调用者和被调用者之间的解耦</strong>，AOP可以说也是这种目标的一种实现</p><h2 id="4-3-统一过程-UP"><a href="#4-3-统一过程-UP" class="headerlink" title="4.3 统一过程 UP"></a>4.3 统一过程 UP</h2><p><img src="https://i.loli.net/2020/03/01/3JSGxNHaBXjOYby.png" alt=""></p><ul><li><p>起始阶段：包括客户沟通和策划活动。该阶段识别基本业务需求，并初步用用例描述每一类用户所需要的主要特性和功能。</p></li><li><p>细化阶段：包括沟通和通用过程模型的建模活动。</p></li><li><p>构建阶段：与通用软件过程中的构建活动相同。</p></li><li><p>转换阶段：包括通用构建活动的后期阶段以及通用部署活动的第一部分。</p></li><li><p>生产阶段：与有通用过程的部署活动一致。</p></li></ul><p>五个阶段不是顺序进行，而是<strong>阶段性并发进行</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程第三章</title>
      <link href="/2020/03/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/2020/03/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程第三章"><a href="#软件工程第三章" class="headerlink" title="软件工程第三章"></a>软件工程第三章</h1><hr><h2 id="3-1-通用过程模型"><a href="#3-1-通用过程模型" class="headerlink" title="3.1 通用过程模型"></a>3.1 通用过程模型</h2><p><strong>过程流</strong>：过程流描述了在执行顺序和执行时间上如何组织框架上的活动、动作和任务。</p><p><strong>线性过程流</strong>：从沟通到部署顺序执行五个框架活动</p><p><strong>迭代过程流</strong>:在执行下一个活动前重复执行之前的一个或多个活动。</p><p><strong>演化过程流</strong>：采用循环的方式执行各个活动，每次循环都能产生更为完善的软件版本。</p><p><strong>并行过程流</strong>：将一个或多个活动与其他活动并行执行<br><img src="https://i.loli.net/2020/03/01/MKom52untCbfSJ7.png" alt=""></p><h2 id="3-2-定义框架活动"><a href="#3-2-定义框架活动" class="headerlink" title="3.2 定义框架活动"></a>3.2 定义框架活动</h2><h2 id="3-3-明确任务集"><a href="#3-3-明确任务集" class="headerlink" title="3.3 明确任务集"></a>3.3 明确任务集</h2><p>任务集定义了为达到一个软件工程工作的目标所需要完成的工作。</p><h2 id="3-4-过程模式"><a href="#3-4-过程模式" class="headerlink" title="3.4 过程模式"></a>3.4 过程模式</h2><p><strong>过程模式</strong>描述了软件工程工作中遇到的过程相关的问题，明确了问题环境并给出了针对该问题的一种或几种可证明的解决方案。</p><p>它更像是提供了一种在软件工程背景下统一描述问题解决问题的方法。<br><em>过程模式提供了描述模式的一般性方法。</em></p><p>以下是Ambler提出的过程模式描述模板：</p><ol><li>模式名称，</li><li>驱动力：模式的使用环境及主要问题</li><li>类型：<ul><li>步骤模式。定义了与过程的框架活动相关的问题</li><li>任务模式。定义了与软件工程动作或是工作任务相关、关系软件工程实践- - 成败的问题</li><li>阶段模式。定义在过程中发生的框架活动序列</li></ul></li><li>启动条件：模式应用的前提条件</li><li>问题</li><li>解决方案</li><li>结果</li><li>已知应用和实例</li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程第二章</title>
      <link href="/2020/03/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2020/03/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程-第二章"><a href="#软件工程-第二章" class="headerlink" title="软件工程 第二章"></a>软件工程 第二章</h1><hr><h2 id="2-1-定义软件工程学科"><a href="#2-1-定义软件工程学科" class="headerlink" title="2.1 定义软件工程学科"></a>2.1 定义软件工程学科</h2><p><strong>软件工程</strong>是：（1）将系统化的、规范的、可量化的方法应用于软件的开发、运行和维护，即将工程化方法应用于软件；（2）对（1）中所述方法的研究。</p><p>软件工程是一种层次化的技术，支持软件工程的<strong>根基在于质量关注点</strong>。<br>软件工程的基础是<strong>过程</strong>层。<br>软件工程<strong>方法</strong>为构建软件提供技术上的解决方案，包括沟通、需求分析、设计建模、程序构造、测试和技术支持。<br>软件工程<strong>工具</strong>为过程和方法提供自动化或半自动化的支持。<br><img src="https://i.loli.net/2020/03/01/oWwZxCsXkdQ9GnY.png" alt=""></p><h2 id="2-2-软件过程"><a href="#2-2-软件过程" class="headerlink" title="2.2 软件过程"></a>2.2 软件过程</h2><p><strong>软件过程</strong>是工作产品构建时所执行的一系列活动、动作和任务的集合。</p><h3 id="2-2-1-过程框架"><a href="#2-2-1-过程框架" class="headerlink" title="2.2.1 过程框架"></a>2.2.1 过程框架</h3><p>一个通用的软件工程过程框架通常包含以下五个活动：</p><ul><li><strong>沟通</strong></li><li><strong>策划</strong></li><li><strong>建模</strong></li><li><strong>构建</strong></li><li><strong>部署</strong></li></ul><h3 id="2-2-2-普适性活动"><a href="#2-2-2-普适性活动" class="headerlink" title="2.2.2 普适性活动"></a>2.2.2 普适性活动</h3><ul><li><strong>软件项目跟踪和控制</strong></li><li><strong>风险管理</strong></li><li><strong>软件质量保证</strong></li><li><strong>技术评审</strong></li><li><strong>测量</strong></li><li><strong>软件配置管理</strong></li><li><strong>可复用管理</strong></li><li><strong>工作产品的准备和生产</strong></li></ul><h2 id="2-3-软件工程实践"><a href="#2-3-软件工程实践" class="headerlink" title="2.3 软件工程实践"></a>2.3 软件工程实践</h2><h3 id="2-3-1-实践的精髓"><a href="#2-3-1-实践的精髓" class="headerlink" title="2.3.1 实践的精髓"></a>2.3.1 实践的精髓</h3><p>-<strong>理解问题</strong><br>-<strong>策划解决方案</strong><br>-<strong>实施计划</strong><br>-<strong>检查结果</strong></p><h3 id="2-3-2-通用原则"><a href="#2-3-2-通用原则" class="headerlink" title="2.3.2 通用原则"></a>2.3.2 通用原则</h3><p>第一原则<strong>存在价值</strong>：为用户提供价值而具有存在价值<br>第二原则<strong>保持简洁</strong>：所有设计都应尽可能简洁，但不是过于简化。有助于构建更易于理解和维护的系统。<br>第三原则<strong>保持愿景</strong>：清晰的愿景是软件项目成功的基础。<br>第四原则<strong>关注使用者</strong><br>第五原则<strong>面向未来</strong>：为各种可能的方案做好准备，提高整个系统的可复用性<br>第六原则<strong>提前计划复用</strong>：提前做好服用计划将降低开发费用，并增加可复用构件以及构建化系统的价值<br>第七原则<strong>认真思考</strong></p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库7</title>
      <link href="/2020/02/29/%E6%95%B0%E6%8D%AE%E5%BA%937/"/>
      <url>/2020/02/29/%E6%95%B0%E6%8D%AE%E5%BA%937/</url>
      
        <content type="html"><![CDATA[<h1 id="7数据库设计和E-R模型"><a href="#7数据库设计和E-R模型" class="headerlink" title="7数据库设计和E-R模型#"></a>7数据库设计和E-R模型#</h1><hr><h2 id="7-1设计过程概览"><a href="#7-1设计过程概览" class="headerlink" title="7.1设计过程概览"></a>7.1设计过程概览</h2><h3 id="7-1-1-设计阶段"><a href="#7-1-1-设计阶段" class="headerlink" title="7.1.1 设计阶段"></a>7.1.1 设计阶段</h3><ul><li><p>数据库设计的最初阶段需要完整地刻画未来数据用户的数据需求。</p></li><li><p>接下来，设计者选择数据模型，并采用所选数据模型的概念将这些需求转化为数据库的概念模式。我们在本章中将研究的实体-联系模型通常用于表示概念设计。<strong>概念模式</strong>定义了数据库中表示的实体、实体的属性、实体之间的联系、以及实体和联系上的约束。通常，概念设计阶段会导致E-R图的构建，它提供了对模式的图形化描述。</p></li><li><p>完善的概念模式还指明企业的功能需求。在功能需求规格说明中，用户描述将在数据上进行的各类操作。（增删改查）</p></li><li><p>从抽象数据模型到数据库实现的转化过程在最后两个设计阶段中进行。</p><ul><li><p>在逻辑设计阶段，设计者将高层概念模式隐射到将使用的数据库系统的实现数据模型上。</p></li><li><p>最后，设计者将所得到的系统特定的数据库模式使用到后续的物理设计阶段。</p></li></ul></li></ul><h3 id="7-1-2-设计选择"><a href="#7-1-2-设计选择" class="headerlink" title="7.1.2 设计选择"></a>7.1.2 设计选择</h3><p>实体：指明所有可明确识别的个体。</p><p>在设计一个数据库模式的时候，我们必须确保避免两个主要缺陷：<em>冗余，不完整。</em></p><h2 id="E-R-模型"><a href="#E-R-模型" class="headerlink" title="E-R 模型"></a>E-R 模型</h2><h3 id="7-2-1-实体集"><a href="#7-2-1-实体集" class="headerlink" title="7.2.1 实体集"></a>7.2.1 实体集</h3><p><strong>实体</strong>：现实世界中可区别于所有其他对象的一个“事物”或“对象”。</p><p><strong>实体集</strong>：相同类型即具有相同性质（或属性）的一个实体集合。<br><img src="https://i.loli.net/2020/02/29/1f6rqBDXdU8j5Ho.png" alt=""></p><p>在建模的过程中，我们通常抽象地使用术语实体集，而不是指某个个别实体的特别集合。我们用术语实体集的<strong>外延</strong>来指属于实体集的实体的实际集合。</p><p>实体通过一组<strong>属性</strong>来表示。属性是实体集中每个成员所拥有的描述性性质。但每个实体在每个属性上都有各自的值。</p><h3 id="7-2-2-联系集"><a href="#7-2-2-联系集" class="headerlink" title="7.2.2 联系集"></a>7.2.2 联系集</h3><p><strong>联系</strong>：指多个实体间的相互关联。</p><p><strong>联系集</strong> ：相同类型联系的集合。</p><p><img src="https://i.loli.net/2020/02/29/ZIcEVtPFYnmSAbU.png" alt=""><br><strong>参与</strong>：实体集之间的关联，也就是说实体集E1，E2…参与联系集R。<br><strong>角色</strong>：实体在联系中扮演的功能。当参与联系集的实体集并非互异的时候，也就是说同样的实体集以不同的角色参与一个联系集多于一次，在这一类联系集中，即有时称作<strong>自环的</strong>联系集中，有必要用显式的角色名来指明实体是如何参与联系实例的。<br>联系也可以具有<strong>描述性属性</strong>。给定的联系集中的一个联系实例必须是由其参与实体唯一标识的，而不必使用描述属性。<br><img src="https://i.loli.net/2020/02/29/TzYagME7rKSDloh.png" alt=""></p><h3 id="7-2-3-属性"><a href="#7-2-3-属性" class="headerlink" title="7.2.3 属性"></a>7.2.3 属性</h3><p>每个属性都有一个可取值的集合，称为该属性的<strong>域</strong>，或者<strong>值集</strong>。正规地说，实体集的属性是将实体集映射到于的函数。</p><p>由于一个实体集可能有多个属性，因此每个实体可以用一组（属性，数据值）来表示，实体集的每个属性对应一个这样的对。</p><p>E-R模型中的属性可以按照如下的属性类型来进行划分：</p><ul><li><strong>简单和复合属性</strong>：简单属性不能划分为更小的部分，复合属性可以再划分为更小的部分。</li><li><strong>单值和多值属性</strong>：为了表示一个属性是多值的，我们用花括号将属性名括住，例如：{phone_number}。在适当的情况下，可以对一个多值属性的取值数目设置上、下界。</li><li><strong>派生属性</strong>：这类属性的值可以从别的相关属性或实体派生出来。例如：age和date_of_birth。</li></ul><p>当实体在某个属性上没有值时，使用空值Null。可以表示缺失未知不适用。</p><h2 id="7-3-约束"><a href="#7-3-约束" class="headerlink" title="7.3 约束"></a>7.3 约束</h2><h3 id="7-3-1-映射基数"><a href="#7-3-1-映射基数" class="headerlink" title="7.3.1 映射基数"></a>7.3.1 映射基数</h3><p>** 映射基数 **，或基数比率，表示一个实体通过一个联系集能关联的实体的个数。（一对一，一对多，多对一，多对多）<br><img src="https://i.loli.net/2020/02/29/s9TU4pnburRvFPi.png" alt=""></p><h3 id="7-3-2-参与约束"><a href="#7-3-2-参与约束" class="headerlink" title="7.3.2 参与约束"></a>7.3.2 参与约束</h3><p>如果实体集E中的每个实体都参与到联系集R的至少一个联系中，实体集E在联系集R中的参与称为<strong>全部</strong>的。</p><p>如果E只有部分实体参与到R的联系中，实体集E到联系集R的参与称为<strong>部分</strong>的。</p><h3 id="7-3-3-码"><a href="#7-3-3-码" class="headerlink" title="7.3.3 码"></a>7.3.3 码</h3><p>码是数据系统中的基本概念。所谓码就是能唯一标识实体的属性，他是整个实体集的性质，而不是单个实体的性质。它包括<em>超码，候选码，主码</em>。码同样用于唯一地标识联系，并从而将联系互相分开。</p><p><strong>超码</strong>是一个或多个属性的集合，这些属性可以让我们在一个实体集中唯一地标识一个实体。如果K是一个超码，那么K的任意超集也是超码，也就是说如果K是超码，那么所有包含K的集合也是超码。　</p><p><strong>候选码</strong>是从超码中选出的，自然地候选码也是一个或多个属性的集合。因为超码的范围太广，很多是我们并不感兴趣即无用处的。所以候选码是最小超码，它们的任意真子集都不能成为超码。</p><p><strong>主码</strong>：被数据库设计者选中的，用来在同一实体集中区分不同实体的候选码；此外，应该选择哪些从不或极少变化的属性</p><h2 id="7-4-从实体集中删除冗余属性"><a href="#7-4-从实体集中删除冗余属性" class="headerlink" title="7.4 从实体集中删除冗余属性"></a>7.4 从实体集中删除冗余属性</h2><h2 id="7-5-E-R联系图"><a href="#7-5-E-R联系图" class="headerlink" title="7.5 E-R联系图"></a>7.5 E-R联系图</h2><h3 id="7-5-1-基本结构"><a href="#7-5-1-基本结构" class="headerlink" title="7.5.1 基本结构"></a>7.5.1 基本结构</h3><p>E-R图包括如下几个主要构件：</p><ul><li><strong>分成两部分的矩形</strong>代表实体集。</li><li><strong>菱形</strong>代表联系集。</li><li><strong>未分割的矩形</strong>代表联系集的属性</li><li><strong>线段</strong>将实体集连接到联系集。</li><li><strong>虚线</strong>将联系集属性连接到联系集。</li><li><strong>双线</strong>显示实体在联系集中的参与度。</li><li><strong>双菱形</strong>代表连接到弱实体集的标志性联系集。<br><img src="https://i.loli.net/2020/02/29/nUOL6NXqA84TsRZ.png" alt=""></li></ul><h3 id="7-5-2-映射函数"><a href="#7-5-2-映射函数" class="headerlink" title="7.5.2 映射函数"></a>7.5.2 映射函数</h3><p><img src="https://i.loli.net/2020/02/29/fHgdpsqQlbYt2RI.png" alt=""></p><p>A-&gt;B表示一个A对应一个B，A-B表示一个A对应多个B </p><p>E-R图还提供了一种描述每个实体参与联系集中的联系的次数的更复杂的约束方法。实体集和二元联系集之间的一条边可以有一个关联的最大和最小的映射函数，用<strong>l…h</strong>的形式表示。l表示最小映射函数，h表示最大映射函数，*表示没有限制。</p><h3 id="7-5-4-角色"><a href="#7-5-4-角色" class="headerlink" title="7.5.4 角色"></a>7.5.4 角色</h3><p>在E-R图中，我们通过在菱形和矩形之间的连线上进行标注来表示角色。</p><h3 id="7-5-5-非二元的联系集"><a href="#7-5-5-非二元的联系集" class="headerlink" title="7.5.5 非二元的联系集"></a>7.5.5 非二元的联系集</h3><h3 id="7-5-6-弱实体集"><a href="#7-5-6-弱实体集" class="headerlink" title="7.5.6 弱实体集"></a>7.5.6 弱实体集</h3><p>没有足够的属性以形成主码的实体集称为<strong>弱实体集</strong>，有主码的实体集称作<strong>强实体集</strong>。</p><p>弱实体集必须与另一个称作<strong>标识</strong>或<strong>属主实体集</strong>的实体集关联才能有意义。即，<em>弱实体集存在依赖于标识实体集</em>，我们称标识实体集<strong>拥有</strong>它所标识的弱实体集。将弱实体集与其标识实体集相连的联系称为<strong>标识性联系</strong>。</p><p>弱实体集的<strong>分辨符</strong>使得我们进行区分依赖于特定强实体集的弱实体集中的实体的属性集合。</p><p><img src="https://i.loli.net/2020/02/29/34s8ZRk6pyBJfSe.png" alt=""></p><h2 id="7-7-3-二元还是N元联系集"><a href="#7-7-3-二元还是N元联系集" class="headerlink" title="7.7.3 二元还是N元联系集"></a>7.7.3 二元还是N元联系集</h2><p>事实上，一个非二元的(n元，n&gt;2)联系集总可以用一组不同的二元联系集来替代。简单起见，考虑一个抽象的三元联系集R，它将实体集A、B和C联系起来。用实体集E替代联系集R,并创建三个联系集，如图：<br><img src="https://i.loli.net/2020/03/01/D6mpRrZcilM3n51.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统概念第一章</title>
      <link href="/2020/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2020/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库系统概念第一章"><a href="#数据库系统概念第一章" class="headerlink" title="数据库系统概念第一章"></a>数据库系统概念第一章</h1><hr><p><strong>数据库管理系统DBMS：</strong> 由一个相互关联的数据的集合（即<strong>数据库DB</strong>）和一组用以访问这些数据的程序组成。         </p><p><strong>数据抽象：</strong>           </p><ul><li><strong>物理层</strong>：最低层次的抽象，描述数据实际上是怎样存储的。物理层详细描述复杂的底层数据结构             </li><li><strong>逻辑层</strong>：比物理层层次稍高的抽象，描述数据库中存储什么数据及这些数据间存在什么关系。虽然逻辑层的简单结构的实现可能涉及复杂的物理层结构，但逻辑层用户不必知道这样的复杂性，这称作<strong>物理数据独立性</strong>。数据库管理员使用抽象的逻辑层，他必须确定数据库中应该保存哪些信息。           </li><li><strong>视图层</strong>：最高层次的抽象，只描述整个数据库的某个部分。数据库系统的很多用户并不需要关心所有的信息，而只需要访问数据库的一部分。系统可以为同一数据库提供多个视图。<br><img src="https://i.loli.net/2020/02/22/hOdi5Qk2T94YXKu.png" alt=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
